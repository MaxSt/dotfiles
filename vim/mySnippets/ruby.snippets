snippet Md
File.open(${1:dump_path}, "wb") { |${2:file}| Marshal.dump(${3:obj}, ${4:$2}) }
snippet Ml
File.open(${1:dump_path}, "rb") { |${2:file}| Marshal.load(${3:$2}) }
snippet Pn
PStore.new(${1})
snippet Yd
File.open(${1:path_to_yml}, "w") { |${2:file}| YAML.dump(${3:obj}, ${4:$2}) }
snippet Yl
File.open(${1:path_to_yml}) { |${2:file}| YAML.load(${3:$2}) }
snippet am
alias_method :${1:new_name}, :${2:old_name}
snippet as
assert ${1:test}, "${2:failure_message}"
snippet asam
assert_alias_method ${1:object}, ${2:alias_name}, ${3:original_name}
snippet asb
assert_boolean ${1:actual}
snippet asc
assert_compare ${1:expected}, ${2:operator}, ${3:actual}
snippet ascd
assert_const_defined ${1:object}, ${2:constant_name}
snippet ase
assert_equal ${1:expected}, ${2:actual}
snippet asem
assert_empty ${1:object}
snippet asf
assert_false ${1:actual}
snippet asfa
assert_fail_assertion { ${1:block} }
snippet asi
assert_include ${1:collection}, ${2:object}
snippet asid
assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:delta_float}
snippet asie
assert_in_epsilon ${1:expected_float}, ${2:actual_float}
snippet asio
assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}
snippet asko
assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}
snippet asm
assert_match /${1:expected_pattern}/, ${2:actual_string}
snippet asn
assert_nil ${1:instance}
snippet asncd
assert_not_const_defined ${1:object}, ${2:constant_name}
snippet asne
assert_not_equal ${1:unexpected}, ${2:actual}
snippet asnem
assert_not_empty ${1:object}
snippet asni
assert_not_include ${1:collection}, ${2:object}
snippet asnid
assert_not_in_delta ${1:expected_float}, ${2:actual_float}
snippet asnie
assert_not_in_epsilon ${1:expected_float}, ${2:actual_float}
snippet asnm
assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}
snippet asnn
assert_not_nil ${1:instance}
snippet asnp
assert_not_predicate ${1:object}, ${2:predicate}
snippet asnr
assert_nothing_raised { ${1:block} }
snippet asnrt
assert_not_respond_to ${1:object}, ${2:method}
snippet asns
assert_not_same ${1:unexpected}, ${2:actual}
snippet asnse
assert_not_send ${1:send_array}
snippet asnt
assert_nothing_thrown { ${1} }
snippet aso
assert_operator ${1:left}, :${2:operator}, ${3:right}
snippet asp
assert_predicate ${1:object}, ${2:predicate}
snippet aspe
assert_path_exist ${1:path}
snippet aspne
assert_path_not_exist ${1:path}
snippet asr
assert_raise(${1:Exception}) { ${2} }
snippet asrko
assert_raise_kind_of(${1:kinds...}) { ${2:block} }
snippet asrm
assert_raise_message ${1:expected_message}
snippet asrt
assert_respond_to ${1:object}, :${2:method}
snippet asse
assert_send ${1:send_array}
snippet ast
assert_throws(:${1:expected}) { ${2} }
snippet astr
assert_true ${1:actual}
snippet bm
TESTS = ${1:10_000}
Benchmark.bmbm do |results|
	${2}
end
snippet case
case ${1}
when ${2}
else
	${3}
end
snippet class
class ${1:_RubyClassNameFromFilename()`}${2}
	${3}
end
snippet classe
class ${1:ErrorClassName} < ${2:StandardError}; end${3}
snippet def
def ${1:name}
	${2}
end
snippet defi
def initialize${1}
	${2}
end
snippet defmm
def method_missing(meth, *args, &blk)
	${1}
end
snippet defs
def self.${1:class_method_name}
	${2}
end
snippet deft
def test_${1:case_name}
	${2}
end
snippet detect
detect { |${1:element}| ${2:body} }
snippet detecto
detect do |${1:element}|
	${2:body}
end
snippet dglob
Dir.glob(${1:"<+dir}"+>) { |${2:file}| ${3} }
snippet do
do
	${1}
end
snippet dop
do |${1:param}|
	${2}
end
snippet ea
each { |${1:element}| ${2:body} }
snippet each
each { |${1:element}| ${2:body} }
snippet each_with_index
each_with_index { |${1:element},${2:i}| ${3:} }
snippet each_with_indexo
each_with_index do |${1:element},${2:i}|
	${3:body}
end

snippet eacho
each do |${1:element}|
	${2:body}
end
snippet eado
each do |${1:element}|
	${2:body}
end
snippet eawi
each_with_index { |${1:element},${2:i}| ${3:} }
snippet eawido
each_with_index do |${1:element},${2:i}|
	${3:body}
end

snippet elsif
elsif ${1:condition}
	${2}
snippet fileeach
File.foreach(${1:"<+path}"+>) { |${2:line}| ${3} }
snippet fopen
File.open(${1:path}, "${2:rwab}") { |${3:file}| ${4} }
snippet fread
File.read(${1})
snippet http_get
require 'net/http'
res = Net::HTTP.get URI.parse('${1:url}')
snippet http_post
require 'net/http'
res = Net::HTTP.post_form URI.parse('${1:url}')${2:, params}
snippet if
if ${1:condition}
	${2}
end
snippet ife
if ${1:condition}
	${2}
else
end
snippet inj
inject(${1:init}) { |${2:total}, ${3:next}| ${4:body} }
snippet injdo
inject(${1:init}) do |${2:total}, ${3:next}|
	${4:body}
end
snippet inject
inject { |${1:total},${2:next}| ${3:body} }
snippet injecto
inject do |${1:total},${2:next}|
	${3:body}
end
snippet ip
ip_addr = request.env['REMOTE_ADDR']
snippet map
map { |${1:element}| ${2:body} }
snippet mapdo
map do |${1:element}|
	${2:body}
end
snippet mapo
map do |${1:element}|
	${2:body}
end
snippet mod
module ${1:_RubyClassNameFromFilename()`}
	${2}
end
snippet module
module ${1:_RubyClassNameFromFilename()`}
	module ClassMethods
		${2}
	end

	module InstanceMethods

	end

	def self.included(receiver)
		receiver.extend         ClassMethods
		receiver.send :include, InstanceMethods
	end
end
snippet nam
namespace :${1:namespace} do
	${2}
end
snippet ope
open(${1:path}, "${2:rwab}") { |${3:io}| ${4} }
snippet pathhere
File.join(File.dirname(__FILE__), *%w[${1:rel_path_here}])
snippet r
attr_reader :${1:attr_names}
snippet reject
reject { |${1:element}| ${2:body} }
snippet rejecto
reject do |${1:element}|
	${2:body}
end
snippet rep
results.report("${1:name}:") { TESTS.times { ${2} } }
snippet rw
attr_accessor :${1:attr_names}
snippet select
select { |${1:element}| ${2:body} }
snippet selecto
select do |${1:element}|
	${2:body}
end
snippet sinc
class << self; self end
snippet sort
sort { |${1:x},${2:y}| ${3:body} }
snippet sorto
sort do |${1:x},${2:y}|
	${3:body}
end
snippet tas
desc "${1:Task description}"
task :${2:task_name}${3: => [:dependent, :tasks]} do
	${4}
end
snippet task
desc "${1:Task description}"
task :${2:task_name}${3: => [:dependent, :tasks]} do
	${4}
end
snippet tc
require "test/unit"

require "${1:library_file_name}"

class Test${2:_RubyClassNameFromFilename()`} < Test::Unit::TestCase
	def test_${3:case_name}
		${4}
	end
end
snippet unless
unless ${1:condition}
	${2}
end
snippet unlesse
unless ${1:condition}
	${2}
else
end
snippet w
attr_writer :${1:attr_names}
snippet while
while ${1:condition}
	${2}
end
snippet xmlr
REXML::Document.new(File.read(${1:path}))
snippet xpa
elements.each(${1}) do |${2:node}|
	${3}
end
snippet zip
zip(${1:enums}) { |${2:row}| ${3} }
