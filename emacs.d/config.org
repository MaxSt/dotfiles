#+TITLE: My GNU Emacs configuration
#+OPTIONS: toc:4 h:4
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing
#+PROPERTY: header-args:emacs-lisp :results silent

* Package Config
** Package + use-package
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC
* Defaults
** global
#+BEGIN_SRC emacs-lisp

  (setq package-enable-at-startup nil
   inhibit-startup-screen t
   x-select-enable-clipboard t
   column-number-mode t
   tab-stop-list (number-sequence 2 120 2))
  (setq-default truncate-lines nil) ; line wrap
  (setq-default indent-tabs-mode nil
                tab-width 2)

  ;; the blinking cursor is nothing, but an annoyance
  (blink-cursor-mode -1)


  (setq-default
   indicate-buffer-boundaries nil  ; don't show where buffer starts/ends
   indicate-empty-lines nil        ; don't show empty lines
   fringes-outside-margins t       ; switches order of fringe and margin
   ;; Keep cursors and highlights in current window only
   cursor-in-non-selected-windows nil
   highlight-nonselected-windows nil
   ;; Disable bidirectional text support for slight performance bonus
   bidi-display-reordering nil
   ;; Remove continuation arrow on right fringe
   ;; fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
   ;;                              fringe-indicator-alist)

   blink-matching-paren nil ; don't blink--too distracting
   )

  ;; disable the annoying bell ring
  (setq ring-bell-function 'ignore)
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  (setq gc-cons-threshold 50000000)

  ;; enable y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; revert buffers automatically when underlying files are changed externally
  (global-auto-revert-mode t)

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

#+END_SRC
  
** flyspell
   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load "ispell"
       (setq ispell-program-name "hunspell")
       (setq ispell-dictionary "de_AT,en_US")
       ;; ispell-set-spellchecker-params has to be called
       ;; before ispell-hunspell-add-multi-dic will work
       (ispell-set-spellchecker-params)
       (ispell-hunspell-add-multi-dic "de_AT,en_US"))

       (add-hook 'prog-mode-hook (lambda () (flyspell-prog-mode)))

   #+END_SRC

** Backups
#+BEGIN_SRC emacs-lisp
  (setq
   make-backup-files t
   version-control t   ; use numbers for backup files
   kept-new-versions 10
   kept-old-versions 0
   delete-old-versions t
   backup-by-copying t
   vc-make-backup-files t
   auto-save-default nil
   backup-directory-alist '(("." . "~/.emacs.d/backup")))
#+END_SRC

** Disable Lockfiles
These are the Files creating in the current Directory for files that have not been saved yet #File#
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

* GUI
** font
#+BEGIN_SRC emacs-lisp
  (set-default-font "Iosevka-11")
  (setq default-frame-alist '((font . "Iosevka-11")))
#+END_SRC
** disable menubar
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode 0)
  (tool-bar-mode -1)     ; disable the tool-bar
  (menu-bar-mode -1)     ; disable the menu-bar
  (global-linum-mode -1)  ; dont show line-numbers everywhere
  (show-paren-mode)
  (electric-pair-mode 1)
#+END_SRC
** fringe
#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'tilde [64 168 16] nil nil 'center)
  (set-fringe-bitmap-face 'tilde 'fringe)
#+END_SRC

** Themes
#+begin_src emacs-lisp
  (load-theme 'flatcolor t)
  (use-package all-the-icons
    :ensure t
    :config
    (use-package all-the-icons-dired
      :ensure t
      :config
      (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
      ))

#+end_src
* custom Functions
#+BEGIN_SRC emacs-lisp
  (defconst org-config-file "~/.emacs.d/config.org")

  (defun my-funcs/reload-dotfile ()
    "Reload '~/.emacs.d/init.el'."
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (defun my-funcs/open-dotfile ()
    "Open '~/.emacs.d/config.org."
    (interactive)
    (find-file org-config-file))


  (defun my-funcs/open-snippet-dir ()
    (interactive)
    (let* ((dir (file-name-as-directory (car yas-snippet-dirs)))
           (path (concat dir (symbol-name major-mode))))
      (dired path)))

  (defun my-funcs/resize-window-down ()
    "Resize a window downwards."
    (interactive)
    (if (window-in-direction 'below)
        (enlarge-window 1)
      (shrink-window 1)))

  (defun my-funcs/resize-window-up ()
    "Resize a window upwards."
    (interactive)
    (if (window-in-direction 'above)
        (enlarge-window 1)
      (shrink-window 1)))

  (defun my-funcs/resize-window-left ()
    "Resize a window leftwards."
    (interactive)
    (if (window-in-direction 'left)
        (enlarge-window-horizontally 1)
      (shrink-window-horizontally 1)))

  (defun my-funcs/resize-window-right ()
    "Resize a window rightwards."
    (interactive)
    (if (window-in-direction 'right)
        (enlarge-window-horizontally 1)
      (shrink-window-horizontally 1)))

  (defun my-funcs/flash-region (start end)
    "Makes the region between START and END change color for a moment"
    (let ((overlay (make-overlay start end)))
      (overlay-put overlay 'face 'swiper-match-face-4)
      (run-with-timer 0.2 nil 'delete-overlay overlay)))


  (defun my-funcs/what-face (pos)
    "Tells you the name of the face (point) is on."
    (interactive "d")
    (let ((hl-line-p (bound-and-true-p hl-line-mode)))
      (if hl-line-p (hl-line-mode -1))
      (let ((face (or (get-char-property (point) 'read-face-name)
                      (get-char-property (point) 'face))))
        (if face (message "Face: %s" face) (message "No face at %d" pos)))
      (if hl-line-p (hl-line-mode 1))))
#+END_SRC

** Session save/restore
#+BEGIN_SRC emacs-lisp
  (require 'desktop)

  (defvar my-desktop-session-dir
    (concat (getenv "HOME") "/.emacs.d/desktop/")
    "*Directory to save desktop sessions in")

  (defvar my-desktop-session-name-hist nil
    "Desktop session name history")

  (defun my-desktop-save (&optional name)
    "Save desktop by name."
    (interactive)
    (unless name
      (setq name (my-desktop-get-session-name "Save session" t)))
    (when name
      (make-directory (concat my-desktop-session-dir name) t)
      (desktop-save (concat my-desktop-session-dir name) t)))

  (defun my-desktop-save-and-clear ()
    "Save and clear desktop."
    (interactive)
    (call-interactively 'my-desktop-save)
    (desktop-clear)
    (setq desktop-dirname nil))

  (defun my-desktop-read (&optional name)
    "Read desktop by name."
    (interactive)
    (unless name
      (setq name (my-desktop-get-session-name "Load session")))
    (when name
      (desktop-clear)
      (desktop-read (concat my-desktop-session-dir name))))

  (defun my-desktop-change (&optional name)
    "Change desktops by name."
    (interactive)
    (let ((name (my-desktop-get-current-name)))
      (when name
        (my-desktop-save name))
      (call-interactively 'my-desktop-read)))

  (defun my-desktop-name ()
    "Return the current desktop name."
    (interactive)
    (let ((name (my-desktop-get-current-name)))
      (if name
          (message (concat "Desktop name: " name))
        (message "No named desktop loaded"))))

  (defun my-desktop-get-current-name ()
    "Get the current desktop name."
    (when desktop-dirname
      (let ((dirname (substring desktop-dirname 0 -1)))
        (when (string= (file-name-directory dirname) my-desktop-session-dir)
          (file-name-nondirectory dirname)))))

  (defun my-desktop-get-session-name (prompt &optional use-default)
    "Get a session name."
    (let* ((default (and use-default (my-desktop-get-current-name)))
           (full-prompt (concat prompt (if default
                                           (concat " (default " default "): ")
                                         ": "))))
      (completing-read full-prompt (and (file-exists-p my-desktop-session-dir)
                                        (directory-files my-desktop-session-dir))
                       nil nil nil my-desktop-session-name-hist default)))

  (defun my-desktop-kill-emacs-hook ()
    "Save desktop before killing emacs."
    (when (file-exists-p (concat my-desktop-session-dir "last-session"))
      (setq desktop-file-modtime
            (nth 5 (file-attributes (desktop-full-file-name (concat my-desktop-session-dir "last-session"))))))
    (my-desktop-save "last-session"))

  (add-hook 'kill-emacs-hook 'my-desktop-kill-emacs-hook)

#+END_SRC
* Evil
** initialize
  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :ensure t
      :init
      (setq-default evil-search-module 'evil-search
                    evil-shift-width 2
                    ;; prevent esc-key from translating to meta-key in terminal mode
                    evil-esc-delay 0
                    evil-want-Y-yank-to-eol t)
      (evil-mode t)
      :config)
  #+end_src
   
** custom text objects
*** sexp
   #+BEGIN_SRC emacs-lisp
        
     ;;Evil smartparens text objects
     (evil-define-text-object evil-a-sexp (count &optional beg end type)
       "outer sexp"
       (evil-range (progn
                     (save-excursion
                       (sp-beginning-of-sexp)
                       (- (point) 1)))
                   (progn
                     (save-excursion
                       (sp-end-of-sexp)
                       (+ (point) 1)))))
     (define-key evil-outer-text-objects-map "f" 'evil-a-sexp)

     (evil-define-text-object evil-i-sexp (count &optional beg end type)
       "inner sexp"
       (evil-range (progn
                     (save-excursion
                       (sp-beginning-of-sexp)
                       (point)))
                   (progn
                     (save-excursion
                       (sp-end-of-sexp)
                       (point)))))
     (define-key evil-inner-text-objects-map "f" 'evil-i-sexp)

     (evil-define-text-object evil-a-top-level-sexp (count &optional beg end type)
       "outer top level sexp"
       (evil-range (progn
                     (save-excursion
                       (beginning-of-defun)
                       (- (point) 1)))
                   (progn
                     (save-excursion
                       (end-of-defun)
                       (+ (point) 1)))))
     (define-key evil-outer-text-objects-map "F" 'evil-a-top-level-sexp)

     (evil-define-text-object evil-i-top-level-sexp (count &optional beg end type)
       "inner top level sexp"
       (evil-range (progn
                     (save-excursion
                       (beginning-of-defun)
                       (point)))
                   (progn
                     (save-excursion
                       (end-of-defun)
                       (point)))))
     (define-key evil-inner-text-objects-map "F" 'evil-i-top-level-sexp)

     (evil-define-text-object evil-a-lisp-element (count &optional beg end type)
       "outer sexp"
       (evil-range (progn
                     (save-excursion
                       ;;TODO
                       ))
                   (progn
                     (save-excursion
                       ;;TODO
                       ))))
     ;;(define-key evil-outer-text-objects-map "e" 'evil-a-lisp-element)

     (evil-define-text-object evil-i-lisp-element (count &optional beg end type)
       "inner sexp"
       (evil-range (progn
                     (save-excursion
                       ;;TODO
                       ))
                   (progn
                     (save-excursion
                       ;;TODO
                       ))))
     ;;(define-key evil-inner-text-objects-map "e" 'evil-i-lisp-element)

   #+end_src
*** line text object
    no mapping for that object 
   #+begin_src emacs-lisp

     (evil-define-text-object evil-i-line (count &optional beg end type)
       "inner line"
       (evil-range (progn
                     (save-excursion
                       (back-to-indentation)
                       (point)))
                   (progn
                     (save-excursion
                       (end-of-line)
                       (point)))))
     (define-key evil-inner-text-objects-map "l" 'evil-i-line)

     (evil-define-text-object evil-a-line (count &optional beg end type)
       "outer line"
       (evil-range (progn
                     (save-excursion
                       (evil-beginning-of-line)
                       (point)))
                   (progn
                     (save-excursion
                       (end-of-line)
                       (point)))))
     (define-key evil-outer-text-objects-map "l" 'evil-a-line)

   #+END_SRC
** General (keybindings)
   [[https://github.com/noctuid/general.el][general.el]]
   #+BEGIN_SRC emacs-lisp
     (use-package general
       :ensure t
       :config
       (general-evil-setup)
       ;; bind a key globally in normal state; keymaps must be quoted
       (setq general-default-keymaps 'evil-normal-state-map))



     ;;evil mappings
     (general-define-key :keymaps 'normal
                         "gs" 'save-buffer
                         "C-h" 'evil-window-left
                         "C-h" 'evil-window-right
                         "C-k" 'evil-window-up
                         "C-j" 'evil-window-down
                         "g ." 'my-funcs/open-dotfile
                         "g h" 'org-capture
                         "g l" 'org-agenda
                         "g o" (lambda ()
                                 (interactive)
                                 (dired org-directory))
                         "] SPC" (lambda ()
                                   (interactive)
                                   (save-excursion
                                     (evil-open-below 1))
                                   (evil-normal-state))
                         "[ SPC" (lambda ()
                                   (interactive)
                                   (save-excursion
                                     (evil-open-above 1))
                                   (evil-normal-state))
                         )
     ;; named prefix key
     (setq my-leader "SPC")
     (general-define-key :prefix my-leader
                         ;;"r" 'restart-emacs
                         "p" 'hydra-projectile/body

                         ;;"h" (general-simulate-keys "C-h")
                         "h k" 'describe-key
                         "h SPC" 'which-key-show-top-level
                         "h v" 'describe-variable
                         "h f" 'describe-function
                         "h m" 'describe-mode

                         ;;  Avoiding CTRL
                         "Wf" 'ace-select-window
                         "Wx" 'ace-swap-window
                         "w" (general-simulate-keys "C-w")
                         "x" (general-simulate-keys "C-x")
                         "c" (general-simulate-keys "C-c")

                         ". s" 'my-funcs/open-snippet-dir
                         "g s" 'magit-status
                         "g t" 'git-timemachine
                         "l" 'evil-avy-goto-line
                         "u" 'undo-tree-visualize
                         "b" 'ivy-switch-buffer
                         "o" (lambda () (interactive) (dired "."))
                         "O" 'dired
                         "f" 'find-file)

     (setq my-leader2 ",")
     (setq local-leader "\\")
   #+END_SRC
** evil-surround
#+begin_src emacs-lisp
    (use-package evil-surround
      :ensure t
      :config
      (global-evil-surround-mode))
#+end_src

** evil-numbers
   increment and decrement numbers with c-a and c-x
#+begin_src emacs-lisp
    (use-package evil-numbers
      :ensure t
      :config
      (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
      (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt))
#+end_src

** evil-matchit
   % to jump between matched tags
#+begin_src emacs-lisp
    (use-package evil-matchit
      :ensure t
      :config
      (global-evil-matchit-mode 1))
#+end_src

** evil-exchange
#+begin_src emacs-lisp
   ;;gx to mark exchange second time to do it
   ;;gX to cancel
  (use-package evil-exchange
    :ensure t
    :config)

  (setq lisp-modes '(clojure-mode
                     cider-clojure-interaction-mode
                     lisp-interaction-mode
                     cider-repl-mode
                     emacs-lisp-mode))

  (evil-define-operator evil-decide-change-fun (beg end)
    "decide which change function to use"
    :move-point nil
    (if (seq-contains lisp-modes major-mode)
        (evil-sp-change beg end)
      (evil-change beg end)))


  (general-nmap "c" (general-key-dispatch 'evil-decide-change-fun
                      :name general-dispatch-evil-change-exchange
                      "s" 'evil-surround-change
                      "x" 'evil-exchange
                      "X" 'evil-exchange-cancel))

#+end_src

** evil-commentary
#+begin_src emacs-lisp
  (use-package evil-commentary
      :ensure t
      :after (evil)
      :config
      (evil-commentary-mode))
#+end_src

** evil-replace-with-register
#+begin_src emacs-lisp
  (use-package evil-replace-with-register
    :ensure t
    :after (evil)
    :config
    (setq evil-replace-with-register-key (kbd "gr"))
    (evil-replace-with-register-install))
#+end_src

* Package config
** PopWin
#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :ensure t
    :config
    (popwin-mode 1))

#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :config)

  (use-package clj-refactor
    :ensure t
    :config)

  (use-package cider
    :ensure t
    :config
    (use-package cider-hydra
      :ensure t
      :config
      (add-hook 'cider-mode-hook #'cider-hydra-mode))

    (push '("*cider-error*" :width 60 :position right) popwin:special-display-config)
    (push '(cider-repl-mode :height 20 :position bottom) popwin:special-display-config)
    (push '(cider-inspector-mode :height 10 :position top) popwin:special-display-config)

    (setq cider-repl-display-in-current-window nil)
    (setq cider-repl-use-pretty-printing t)
    (autoload 'cider--make-result-overlay "cider-overlays")

    (defun my-funcs/eval-overlay (value point)
      (cider--make-result-overlay (format "%S" value)
        :where point
        :duration 'command)
      ;; Preserve the return value.
      value)

    (advice-add 'eval-last-sexp :filter-return
                (lambda (r)
                  (my-funcs/eval-overlay r (point))))

    (advice-add 'eval-defun :filter-return
                (lambda (r)
                  (my-funcs/eval-overlay
                   r
                   (save-excursion
                     (end-of-defun)
                     (point))))))

  (evil-define-operator evil-eval-clojure-text-object (beg end)
    "Evil operator for evaluating code."
    :move-point nil
    (save-excursion
      (my-funcs/flash-region beg end)
      (cider-eval-region beg end)))

  (general-define-key :keymaps '(cider-inspector-mode-map)
                      :states '(normal)
                      "n" 'cider-inspector-next-page
                      "N" 'cider-inspector-prev-page
                      "RET" 'cider-inspector-operate-on-point
                      "d" 'cider-inspector-pop
                      "r" 'cider-inspector-refresh)

  (general-define-key :keymaps '(cider-popup-buffer-mode-map cider-stacktrace-mode-map)
                      :states '(normal)
                      "q" 'cider-popup-buffer-quit)

  (general-define-key :prefix local-leader
                      :keymaps '(clojure-mode-map cider-repl-mode-map cider-clojure-interaction-mode-map)
                      :states '(normal)
                      "r" 'cider-hydra-repl/body
                      "j" 'cider-jack-in
                      "i" 'cider-inspect-last-result
                      "c" 'cider-jack-in
                      "d" 'cider-hydra-doc/body
                      "e" 'cider-hydra-eval/body
                      "q" 'hydra-cljr-help-menu/body)

  (general-define-key :keymaps '(clojure-mode-map cider-repl-mode-map cider-clojure-interaction-mode-map)
                      :states '(normal)
                      "c" (general-key-dispatch 'general-dispatch-evil-change-exchange
                      :name general-dispatch-change-clojure
                            "p" (general-key-dispatch 'evil-eval-clojure-text-object
                                  :name general-dispatch-eval-clojure-text-object
                                  "p" (lambda ()
                                        (interactive)
                                        (let* ((range (evil-a-sexp))
                                               (beg (elt range 0))
                                               (end (elt range 1)))
                                          (evil-eval-clojure-text-object beg end))))
                            ;; could be used for other operators where there
                            ;; isn't an existing command for the linewise version:
                            ;; "c" (general-simulate-keys ('evil-change "c"))
                            ))



#+end_src

** elisp
   #+BEGIN_SRC emacs-lisp
     ;;todo only for elisp!
     (evil-define-operator evil-eval-elisp-text-object (beg end)
       "Evil operator for evaluating code."
       :move-point nil
       (save-excursion
         (let (eval-str
               value)
           (setq eval-str (buffer-substring beg end))
           (setq value (eval (car (read-from-string eval-str))))
           (my-funcs/flash-region beg end)
           (my-funcs/eval-overlay value end)
           (message (format "%s" value)))))

     (general-define-key :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
                         :states '(normal)
                         "c" (general-key-dispatch 'general-dispatch-evil-change-exchange
                               :name general-dispatch-change-elisp
                               "p" (general-key-dispatch 'evil-eval-elisp-text-object
                                     :name general-dispatch-eval-elisp-text-object
                                     "p" (lambda ()
                                           (interactive)
                                           (let* ((range (evil-a-sexp))
                                                  (beg (elt range 0))
                                                  (end (elt range 1)))
                                             (evil-eval-elisp-text-object beg end))))))

   #+END_SRC
** lisp general
#+BEGIN_SRC emacs-lisp
  (defun maybe-join-lisp-line (orig-fun &rest r)
    (apply orig-fun r)
    (when (string-match-p "^\s*[\])}]+\s*$" (thing-at-point 'line t))
      (evil-previous-line-first-non-blank)
      (save-excursion (join-line 1))))

  (advice-add 'evil-sp-delete-line :around 'maybe-join-lisp-line)
  (advice-add 'evil-sp-delete :around 'maybe-join-lisp-line)


  (defun in-sexp ()
    (> (nth 0 (syntax-ppss)) 0))

  (defun next-paren (&optional closing)
    "Go to the next/previous closing/opening parenthesis/bracket/brace."
    (if closing
        (let ((curr (point)))
          (forward-char)
          (unless (eq curr (search-forward-regexp "[])}]"))
            (backward-char)))
      (search-backward-regexp "[[({]")))


  (defun prev-opening-paren ()
    "Go to the next closing parenthesis."
    (interactive)
    (next-paren))

  (defun next-closing-paren ()
    "Go to the next closing parenthesis."
    (interactive)
    (next-paren 'closing))


  (defmacro open-paren-around-fn (paren element beginning)
    `(lambda ()
       (interactive)
       (sp-wrap-with-pair ,paren)
       ,(when element
          '(when (in-sexp)
             (next-paren)
             (evil-forward-char 1)))
       ,(if beginning
            '(progn
               (insert " ")
               (evil-backward-char 1))
          '(progn
             (evilmi-jump-items)
             (evil-forward-char 1)))
       (evil-insert nil)))

  (evil-define-command lisp-next-paren (count)
    (interactive "<c>")
    (if count
        (dotimes (number count)
          (sp-next-sexp))
      (sp-next-sexp)))

  (evil-define-command lisp-previous-paren (count)
    (interactive "<c>")
    (if count
        (dotimes (number count)
          (sp-previous-sexp))
      (sp-previous-sexp)))

  (general-define-key :prefix my-leader2
                      :keymaps '(clojure-mode-map
                                 cider-clojure-interaction-mode-map
                                 lisp-interaction-mode-map
                                 cider-repl-mode-map
                                 emacs-lisp-mode-map)
                      :states '(normal)
                      "W" (open-paren-around-fn "(" t nil)
                      "w" (open-paren-around-fn "(" t t)
                      "e)" (open-paren-around-fn "(" t nil)
                      "e(" (open-paren-around-fn "(" t t)
                      "e}" (open-paren-around-fn "{" t nil)
                      "e{" (open-paren-around-fn "{" t t)
                      "e]" (open-paren-around-fn "[" t nil)
                      "e[" (open-paren-around-fn "[" t t)
                      "e}" (open-paren-around-fn "{" t nil)
                      "e{" (open-paren-around-fn "{" t t)
                      "i" (open-paren-around-fn "(" nil t)
                      "I" (open-paren-around-fn "(" nil nil)
                      "(" (open-paren-around-fn "(" nil t)
                      ")" (open-paren-around-fn "(" nil nil)
                      "[" (open-paren-around-fn "[" nil t)
                      "]" (open-paren-around-fn "]" nil nil)
                      "{" (open-paren-around-fn "{" nil t)
                      "}" (open-paren-around-fn "}" nil nil)
                      "@" 'sp-splice-sexp
                      "o" (lambda ()
                            (interactive)
                            (when (string-match-p "^[^\[({]" (thing-at-point 'sexp t))
                              (sp-backward-up-sexp))
                            (sp-raise-sexp))
                      "O" 'sp-raise-sexp)

  (general-define-key :keymaps '(clojure-mode-map
                                 cider-clojure-interaction-mode-map
                                 lisp-interaction-mode-map
                                 cider-repl-mode-map
                                 emacs-lisp-mode-map)
                      :states '(normal)
                      ;; c is defined in vim-exchange
                      "W" 'lisp-next-paren
                      "B" 'lisp-previous-paren


                      "(" 'sp-backward-up-sexp
                      ")" (lambda ()
                            (interactive)
                            (sp-backward-up-sexp)
                            (evilmi-jump-items))

                      ">" (general-key-dispatch 'evil-shift-right
                            "I" (lambda ()
                                  (interactive)
                                  (sp-end-of-sexp)
                                  (when (not (char-equal (preceding-char)  ?  ))
                                    (insert " "))
                                  (evil-insert nil))
                            "f" (lambda ()
                                  (interactive)
                                  (when (in-sexp)
                                    ))
                            ")" 'sp-forward-slurp-sexp
                            "(" 'sp-backward-barf-sexp)
                      "<" (general-key-dispatch 'evil-shift-left
                            "I" (lambda ()
                                  (interactive)
                                  (sp-beginning-of-sexp)
                                  (when (not (char-equal (following-char)  ?  ))
                                    (insert " ")
                                    (evil-backward-char))
                                  (evil-insert nil))
                            ")" 'sp-forward-barf-sexp
                            "(" 'sp-backward-slurp-sexp)
                      "C" 'evil-sp-change-line
                      "d" 'evil-sp-delete
                      "D" 'evil-sp-delete-line)


#+END_SRC
** neotree
#+begin_src emacs-lisp
  (use-package neotree
    :ensure t
    :general
    (:keymaps 'neotree-mode-map
              "TAB" 'neotree-enter
              "q" 'neotree-hide
              "RET" 'neotree-enter)
    (:keymaps 'evil-normal-state-map
              "|" 'neotree-toggle)
    :config
    (setq neo-theme (if window-system 'icons 'arrow)))
#+end_src
** which-key
#+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :config
      (which-key-mode))
#+END_SRC
   
** Terminal
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :ensure t
  :config
  (add-hook 'term-mode-hook (lambda () (yas-minor-mode -1))))

(defun my-term-funcs/send-ctrl-a ()
  "Go to beginning of line."
  (interactive)
  (term-send-raw-string "\C-a"))

(defun my-term-funcs/send-ctrl-e ()
  "Go to end of line."
  (interactive)
  (term-send-raw-string "\C-e"))

(defun my-term-funcs/send-ctrl-r ()
  "Start reverse history search."
  (interactive)
  (term-send-raw-string "\C-r"))

(defun my-term-funcs/send-ctrl-p ()
  "Go back in history."
  (interactive)
  (term-send-raw-string "\C-p"))

(defun my-term-funcs/send-ctrl-n ()
  "Go forward in history."
  (interactive)
  (term-send-raw-string "\C-n"))

(defun my-term-funcs/send-ctrl-c ()
  "Send Ctrl+C."
  (interactive)
  (term-send-raw-string "\C-c"))

(defun my-term-funcs/send-ctrl-d ()
  "Send EOF."
  (interactive)
  (term-send-raw-string "\C-d"))

(defun my-term-funcs/send-ctrl-z ()
  "Suspend."
  (interactive)
  (term-send-raw-string "\C-z"))

(defun my-term-funcs/send-space ()
  "Send space."
  (interactive)
  (term-send-raw-string " "))

(defun my-term-funcs/toggle-term ()
  "Toggle the dedicated terminal."
  (interactive)
  (multi-term-dedicated-toggle)
  (multi-term-dedicated-select))

(defun my-term-funcs/send-tab ()
  "Send tab."
  (interactive)
  (term-send-raw-string "\t"))

(add-hook 'term-mode-hook
	  (lambda ()
	    (evil-define-key 'normal term-raw-map
	      (kbd "\C-j") 'evil-window-down
	      (kbd "\C-k") 'evil-window-up
	      (kbd "p") 'term-paste)
	    (evil-define-key 'insert term-raw-map
	      (kbd "\C-j") 'evil-window-down
	      (kbd "\C-k") 'evil-window-up
	      (kbd "\C-a") 'my-term-funcs/send-ctrl-a
	      (kbd "\C-e") 'my-term-funcs/send-ctrl-e
	      (kbd "\C-r") 'my-term-funcs/send-ctrl-r
	      (kbd "\C-p") 'my-term-funcs/send-ctrl-p
	      (kbd "\C-n") 'my-term-funcs/send-ctrl-n
	      (kbd "\C-c") 'my-term-funcs/send-ctrl-c
	      (kbd "\C-d") 'my-term-funcs/send-ctrl-d
	      (kbd "\C-z") 'my-term-funcs/send-ctrl-z
	      (kbd "SPC")  'my-term-funcs/send-space    ; must use this, or else smart-space overrides space here
	      (kbd "TAB")  'my-term-funcs/send-tab
	      [tab]        'my-term-funcs/send-tab
	      (kbd "\C-w") 'term-send-backward-kill-word)))
#+END_SRC

# ** helm
# #+BEGIN_SRC emacs-lisp
# (use-package helm
#   :ensure t
#   :config
#   (setq helm-buffers-fuzzy-matching t
# 	helm-recentf-fuzzy-match    t)
#   (setq helm-quick-update t
#         ;; Speedier without fuzzy matching
#         helm-mode-fuzzy-match t
#         helm-buffers-fuzzy-matching t
#         helm-apropos-fuzzy-match t
#         helm-M-x-fuzzy-match t
#         helm-recentf-fuzzy-match t
#         helm-projectile-fuzzy-match nil
#         ;; Display extraineous helm UI elements
#         helm-display-header-line nil
#         helm-ff-auto-update-initial-value nil
#         helm-find-files-doc-header nil
#         ;; Don't override evil-ex's completion
#         helm-mode-handle-completion-in-region nil
#         helm-candidate-number-limit 50
#         ;; Don't wrap item cycling
#         helm-move-to-line-cycle-in-source t)

#   (define-key helm-map (kbd "C-j") 'helm-next-line)
#   (define-key helm-map (kbd "C-k") 'helm-previous-line)
#   (define-key helm-map (kbd "C-w") 'backward-kill-word)
#   (define-key helm-map (kbd "TAB") 'helm-execute-persistent-action) ; complete with tab
#   (global-set-key (kbd "M-x") 'helm-M-x)
#   (helm-mode 1)

#   ;;always bottom 40% height
#   (add-to-list 'display-buffer-alist
# 	       `(,(rx bos "*helm" (* not-newline) "*" eos)
# 		 (display-buffer-in-side-window)
# 		 (inhibit-same-window . t)
# 		 (window-height . 0.4)))

#   (use-package helm-projectile
#     :ensure t
#     :config
#     (helm-projectile-on))
#   (use-package helm-ag
#     :ensure t
#     :config))
# #+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (setq flycheck-indication-mode 'right-fringe)
  :config
  (global-flycheck-mode)
  (define-fringe-bitmap 'flycheck-fringe-bitmap-double-arrow
    [0 0 0 0 0 4 12 28 60 124 252 124 60 28 12 4 0 0 0 0])
  )
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  ;(define-key yas-minor-mode-map [tab] nil)
  ;(define-key yas-minor-mode-map (kbd "TAB") nil)

  ;(define-key yas-keymap [tab] 'my-funcs/tab-complete-or-next-field)
  ;(define-key yas-keymap (kbd "TAB") 'my-funcs/tab-complete-or-next-field)
  ;(define-key yas-keymap [(control tab)] 'yas-next-field)
  ;(define-key yas-keymap (kbd "C-g") 'my-funcs/abort-company-or-yas)

  (yas-global-mode 1))
#+END_SRC

** company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (setq company-idle-delay 0.2
	company-minimum-prefix-length 2)
  (define-key company-active-map (kbd "M-n") nil)
  (define-key company-active-map (kbd "M-p") nil)
  (define-key company-active-map (kbd "C-n") #'company-select-next)
  (define-key company-active-map (kbd "C-p") #'company-select-previous)
  (define-key company-active-map (kbd "C-w") #'backward-kill-word)
  ;(define-key company-active-map [tab] 'my-funcs/expand-snippet-or-complete-selection)
  ;(define-key company-active-map (kbd "TAB") 'my-funcs/expand-snippet-or-complete-selection)
  (nconc company-backends '(company-yasnippet))
  (global-company-mode))
#+END_SRC

** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :config
    (defhydra hydra-zoom ()
      "Zoom"
      ("+" zoom-in "in")
      ("-" zoom-out "out"))

    (defhydra hydra-window-resize ()
      "Window resizing"
      ("j" my-funcs/resize-window-down "down")
      ("k" my-funcs/resize-window-up "up")
      ("l" my-funcs/resize-window-right "right")
      ("h" my-funcs/resize-window-left "left")))

  (defhydra hydra-projectile (:color teal :columns 4)
    "Projectile"
    ("f"   projectile-find-file                "Find File")
    ("r"   projectile-recentf                  "Recent Files")
    ("z"   projectile-cache-current-file       "Cache Current File")
    ("x"   projectile-remove-known-project     "Remove Known Project")

    ("d"   projectile-find-dir                 "Find Directory")
    ("b"   projectile-switch-to-buffer         "Switch to Buffer")
    ("c"   projectile-invalidate-cache         "Clear Cache")
    ("X"   projectile-cleanup-known-projects   "Cleanup Known Projects")

    ("o"   projectile-multi-occur              "Multi Occur")
    ("p"   projectile-switch-project           "Switch Project")
    ("k"   projectile-kill-buffers             "Kill Buffers")
    ("q"   nil "Cancel" :color blue))

#+END_SRC

** git
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :config
    (use-package git-gutter-fringe
      :ensure t)
    (use-package fringe-helper
      :ensure t)
    (require 'fringe-helper)
    (require 'git-gutter-fringe)

    (fringe-mode 3)
    ;; (push `(left-fringe  . 3) default-frame-alist)
    ;; (push `(right-fringe . 3) default-frame-alist)
    ;; ;; slightly larger default frame size on startup
    ;; (push '(width . 120) default-frame-alist)
    ;; (push '(height . 40) default-frame-alist)
    ;; (define-fringe-bitmap 'tilde [64 168 16] nil nil 'center)
    ;; (set-fringe-bitmap-face 'tilde 'fringe)

    ;; colored fringe "bars"
    (define-fringe-bitmap 'git-gutter-fr:added
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:modified
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'center)

    (advice-add 'evil-force-normal-state :after 'git-gutter)
    (add-hook 'focus-in-hook 'git-gutter:update-all-windows))

  (use-package magit
    :ensure t
    :config
    (use-package evil-magit
      :ensure t)
    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))

    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen)))


  (use-package git-timemachine
    :ensure t
    :after general
    :config
    (general-define-key :keymaps '(git-timemachine-mode-map)
                        :states '(normal)
                        :prefix my-leader2
                        "n" 'git-timemachine-show-next-revision
                        "p" 'git-timemachine-show-previous-revision
                        "r" 'git-timemachine-show-current-revision
                        "q" 'git-timemachine-quit))
#+END_SRC

** Org Mode
*** org settings
   enable syntax highlighting in org-babel source code
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC
   set org default directory
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Dropbox/org/"))
(setq org-directory "~/Dropbox/org")
#+END_SRC
   
*** capture templates
  #+BEGIN_SRC emacs-lisp
    (setq org-capture-templates
          '(("n"
             "new Note"
             entry
             (file "notes.org")
             "* %?")
            ("t"
             "My TODO task format."
             entry
             (file "todo.org")
             "* TODO %? SCHEDULED: %t")))

    (setq org-refile-use-outline-path 'file)
    (setq org-outline-path-complete-in-steps nil)

    ;; use a depth level of 6 max
    (setq org-refile-targets
          '((org-agenda-files . (:maxlevel . 4))))

  #+END_SRC 
*** agenda keybindings
*** org-bullets (pretty bullets)
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook
              (lambda ()
                (org-bullets-mode 1))))
#+END_SRC

*** org-Reveal (HTML presentations)
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t)
  ;;(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
  ;;(setq org-reveal-mathjax t)

  (use-package htmlize
  :ensure t)
#+END_SRC

*** evil keybindings in org-mode
#+BEGIN_SRC emacs-lisp
  (defun clever-insert-item ()
    "Clever insertion of org item."
    (if (not (org-in-item-p))
        (insert "\n")
      (org-insert-item))
    )

  (defun evil-org-eol-call (fun)
    "Go to end of line and call provided function.
  FUN function callback"
    (end-of-line)
    (funcall fun)
    (evil-append nil)
    )

  (general-define-key :keymaps 'org-mode-map
                      :states '(normal)
                      "TAB" 'org-cycle
                      "<" 'org-metaleft
                      ">" 'org-metaright

                      ;; "o" '(lambda ()
                      ;;        (interactive)
                      ;;        (end-of-line)
                      ;;        (org-meta-return)
                      ;;        (evil-append nil))

                      "RET" (lambda ()
                              (interactive)
                              (if (org-in-src-block-p)
                                  (org-edit-special)
                                (org-open-at-point))
                              (evil-normal-state)))


  (general-define-key :prefix my-leader2
                      :keymaps 'org-mode-map
                      :states '(normal)
                      "o" (lambda ()
                            (interactive)
                            (org-insert-heading-after-current)
                            (evil-insert-state))
                      "s" 'org-schedule
                      "r" 'org-refile
                      "t" 'org-todo
                      "p" 'org-insert-link
                      "y" 'org-store-link
                      "l" 'org-forward-heading-same-level
                      "h" 'org-backward-heading-same-level
                      "k" 'org-up-element
                      "K" (lambda ()
                            (interactive)
                            (org-up-element)
                            (org-cycle)))

  ;; key for exiting src edit mode
  (general-define-key :keymaps 'org-src-mode-map
                      :states '(normal)
                      "RET" 'org-edit-src-exit)

#+END_SRC

*** open source code in same window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
    
** smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config

    (use-package evil-smartparens
      :ensure t
      :config)

  ;;(advice-add 'evil-sp-delete :after')
             
            



    ;;(general-define-key ')

    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (sp-local-pair 'clojure-mode "'" nil :actions nil)
    (sp-local-pair 'lisp-interaction-mode "'" nil :actions nil)
    (sp-local-pair 'clojure-interaction-mode "'" nil :actions nil)
    (sp-local-pair 'cider-repl-mode "'" nil :actions nil)
    (smartparens-global-mode 1))
#+END_SRC
** Latex
*** AucTex
#+BEGIN_SRC emacs-lisp
  (use-package auctex-latexmk
    :ensure t
    :config
    (auctex-latexmk-setup))

  (add-hook 'LaTeX-mode-hook (lambda ()
    (push
      '("latexmk" "latexmk -pdf -pvc %s" TeX-run-TeX nil t
        :help "Run latexmk on file")
      TeX-command-list)))
  (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
  (add-hook 'TeX-mode-hook '(lambda () (flyspell-mode 1)))
   #+END_SRC
** projectile
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-completion-system 'ivy)
    (projectile-global-mode))
#+end_src

** ag
#+begin_src emacs-lisp
  (use-package ag
    :ensure t)

#+end_src
** rainbow-delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config

    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-repl-mode #'rainbow-delimiters-mode)
    )
#+end_src

** undo-tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :config
    (progn 
      (global-undo-tree-mode)
      (setq undo-tree-auto-save-history t
            undo-tree-visualizer-diff t
            undo-tree-visualizer-timestamps t
            undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))))
#+end_src
** recentf
   for keeping track of recent files, provides helm-recentf with data
   #+begin_src emacs-lisp
     (use-package recentf
       :ensure t
       :config
       (recentf-mode 1)
       )
   #+end_src
** powerline
#+BEGIN_SRC emacs-lisp

  (use-package powerline
    :ensure t
    :config

    (defun make-rect (color height width)
      "Create an XPM bitmap."
      (when window-system
        (propertize
         " " 'display
         (let ((data nil)
               (i 0))
           (setq data (make-list height (make-list width 1)))
           (pl/make-xpm "percent" color color (reverse data))))))


    (defun powerline-mode-icon ()
      (let ((icon (all-the-icons-icon-for-buffer)))
        (unless (symbolp icon) ;; This implies it's the major mode
          (format " %s"
                  (propertize icon
                              'help-echo (format "Major-mode: `%s`" major-mode)
                              'face `(:height 1.2 :family ,(all-the-icons-icon-family-for-buffer)))))))


    (setq-default mode-line-format 
                  '("%e"
                    (:eval
                     (let* ((active (powerline-selected-window-active))
                            (modified (buffer-modified-p))
                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                            (bar-color (cond ((and active modified) (face-foreground 'error))
                                             (active (face-background 'cursor))
                                             (t (face-background 'tooltip))))
                            (lhs (list
                                  (make-rect bar-color 30 3)
                                  (when modified
                                    (concat
                                     " "
                                     (all-the-icons-faicon "floppy-o"
                                                           :face (when active 'error)
                                                           :v-adjust -0.01)))
                                  " "
                                  (powerline-buffer-id)
                                  ))
                            (center (list
                                     " "
                                     (powerline-mode-icon)
                                     " "
                                     (powerline-major-mode)
                                     " "))
                            (rhs (list

                                  (powerline-raw "%l:%c" 'mode-line 'r)
                                  " | "
                                  (powerline-raw "%6p" 'mode-line 'r)
                                  (powerline-hud 'highlight 'region 1)
                                  " "
                                  ))
                            )
                       (concat
                        (powerline-render lhs)
                        (powerline-fill-center face1 (/ (powerline-width center) 2.0))
                        (powerline-render center)
                        (powerline-fill face2 (powerline-width rhs))
                        (powerline-render rhs))))))
    )
#+END_SRC
** ivy
  http://oremacs.com/swiper/
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :config
    ;; regex order 
    (setq ivy-re-builders-alist '((t . ivy--regex-ignore-order)))

    (define-key ivy-mode-map [escape] 'minibuffer-keyboard-quit)
    (ivy-mode t))

  (use-package counsel
    :ensure t
    :config)

  (use-package swiper
    :ensure t
    :config
    (ivy-mode t))

  (use-package avy
    :ensure t
    :config)

  (use-package ace-window
    :ensure t
    :config)

#+END_SRC
** rainbow-mode
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :config)
#+end_src

** command-log-mode
#+begin_src emacs-lisp
  (use-package command-log-mode
    :ensure t
    :config)
#+end_src

** eyebrowse
#+begin_src emacs-lisp
  (use-package eyebrowse
    :ensure t
    :config
    (eyebrowse-setup-opinionated-keys) ;set evil keybindings (gt gT)
    (eyebrowse-mode t))
#+end_src

** highlight-symbol
#+begin_src emacs-lisp
  (use-package highlight-symbol
    :ensure t
    :config
    (setq highlight-symbol-idle-delay 1)
    (highlight-symbol-mode t)
    )
#+end_src
** aggressive indent
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (global-aggressive-indent-mode))
#+end_src
** dired
*** settings
    move files to trash
    #+BEGIN_SRC emacs-lisp
      (setq delete-by-moving-to-trash t)
    #+END_SRC

    Human readable filesize
    #+BEGIN_SRC emacs-lisp
      (setq dired-listing-switches "-alh")
    #+END_SRC

    Prevents dired from creating an annoying popup when dired-find-alternate-file is called.
#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
    
   Recursive copy and deletion
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always
        dired-recursive-deletes 'always)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (defun my/dired-up-directory ()
    "Take dired up one directory, but behave like dired-find-alternative-file (leave no orphan buffer)"
    (interactive)
    (let ((old (current-buffer)))
      (dired-up-directory)
      (kill-buffer old)))

  (defun my/dired-create-file (file)
    (interactive
     (list
      (read-file-name "Create file: " (dired-current-directory))))
    (write-region "" nil (expand-file-name file) t)
    (dired-add-file file)
    (revert-buffer)
    (dired-goto-file (expand-file-name file)))


  (general-define-key :keymaps '(dired-mode-map)
                      :states '(normal)
                      "h" 'my/dired-up-directory
                      "DEL" 'my/dired-up-directory
                      "RET" 'dired-find-alternate-file
                      "TAB" 'dired-subtree-toggle
                      "l" 'dired-find-alternate-file
                      "c" 'dired-do-rename
                      "f" 'counsel-file-jump
                      "o" 'my/dired-create-file
                      "O" 'dired-create-directory
                      "n" 'evil-search-next
                      "N" 'evil-search-previous
                      "q" 'kill-this-buffer
                      "!" 'dired-do-shell-command)

#+END_SRC
*** Dired+
Dired enhancements.
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :after (dired)
    :config
    (diredp-toggle-find-file-reuse-dir 1))
#+END_SRC
*** dired-subtree
Show subtree when pressing i
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :after (dired)
    :config)
#+END_SRC
*** dired-details
    toggle details with ')'
    #+BEGIN_SRC emacs-lisp
      (use-package dired-details+
        :ensure t
        :config)
    #+END_SRC

** restclient
#+begin_src emacs-lisp
  (use-package restclient
    :ensure t
    :config
    (push '("*HTTP Response*" :height 20 :position bottom) popwin:special-display-config))
#+end_src

*  Temp
#+begin_src emacs-lisp
  ;; (use-package nlinum
  ;;   :ensure t
  ;;   :init
  ;;   (progn
  ;;     (setq nlinum-format "%3d ")
  ;;     ))

  ;; (use-package nlinum-relative
  ;;   :ensure t
  ;;   :init
  ;;   (progn
  ;;     ;;(add-hook 'prog-mode-hook 'nlinum-relative-mode)
  ;;     (global-nlinum-relative-mode t)
  ;;     (setq nlinum-relative-current-symbol "")
  ;;     (nlinum-relative-setup-evil)))


  ;; default values for indentation (possibly overwritten by editorconfig)
  (setq
   js2-basic-offset 2
   js-indent-level 2
   js-expr-indent-offset -2)
#+end_src



#+begin_src emacs-lisp



  ;; Don't litter my init file
  (setq custom-file "~/.emacs.d/local/custom-set.el")
  (load custom-file 'noerror)




  ;; (setq-default mode-line-format
  ;;               (append 
  ;;                (list
  ;;                 ;; value of `mode-name'
  ;;                 '(:eval (powerline-mode-icon)))
  ;;                mode-line-format))

                                          ; Default dictionary to use

  ;;TODO saveplace
  ;;TODO savehist

#+END_SRC
