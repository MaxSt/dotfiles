#+TITLE: My GNU Emacs configuration
#+OPTIONS: toc:4 h:4
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing
#+PROPERTY: header-args:emacs-lisp :results silent :tangle yes
* Package Config
** Emacs Initialization
*** Settings
Set Lexical binding to true
#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

We're going to increase the gc-cons-threshold to a very high number to decrease the load and compile time.
We'll lower this value significantly after initialization has completed. We don't want to keep this value
too high or it will result in long GC pauses during normal usage.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
  ;; Speed up startup
  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (setq gc-cons-threshold 80000000)
  (add-hook 'emacs-startup-hook
            (lambda ()
              "Restore defalut values after init."
              ;; we append default-file-name-handler-alist with the current
              ;; file-name-handler-alist in order to set the values we have set in
              ;; the init config.
              (setq file-name-handler-alist (append default-file-name-handler-alist file-name-handler-alist))
              (setq gc-cons-threshold 800000)
              (if (boundp 'after-focus-change-function)
                  (add-function :after after-focus-change-function
                                (lambda ()
                                  (unless (frame-focus-state)
                                    (garbage-collect))))
  (add-hook 'focus-out-hook 'garbage-collect))))
  )
#+END_SRC

Disable certain byte compiler warnings to cut down on the noise. This is a personal choice and can be removed
if you would like to see any and all byte compiler warnings.

#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
*** Package Management

**** Package Settings
We're going to set the =load-path= ourselves and avoid calling =(package-initilize)= (for
performance reasons) so we need to set =package--init-file-ensured= to true to tell =package.el=
to not automatically call it on our behalf. Additionally we're setting
=package-enable-at-startup= to nil so that packages will not automatically be loaded for us since
=use-package= will be handling that.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir "~/.emacs.d/elpa"
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t)))
#+END_SRC

**** Use-Package Settings
Tell =use-package= to always defer loading packages unless explicitly told otherwise. This speeds up
initialization significantly as many packages are only loaded later when they are explicitly used.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq use-package-always-defer t
          use-package-always-ensure t
          use-package-verbose t))
#+END_SRC

**** Manually Set Load Path
We're going to set the load path ourselves so that we don't have to call =package-initialize= at
runtime and incur a large performance hit. This load-path will actually be faster than the one
created by =package-initialize= because it appends the elpa packages to the end of the load path.
Otherwise any time a builtin package was required it would have to search all of third party paths
first.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
#+END_SRC

**** Initialize Package Management
Next we are going to require =package.el= and add our additional package archives, 'melpa' and 'org'.
Afterwards we need to initialize our packages and then ensure that =use-package= is installed, which
we promptly install if it's missing. Finally we load =use-package= and tell it to always install any
missing packages.

Note that this entire block is wrapped in =eval-when-compile=. The effect of this is to perform all
of the package initialization during compilation so that when byte compiled, all of this time consuming
code is skipped. This can be done because the result of byte compiling =use-package= statements results
in the macro being fully expanded at which point =use-package= isn't actually required any longer.

Since the code is automatically compiled during runtime, if the configuration hasn't already been
previously compiled manually then all of the package initialization will still take place at startup.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
  (unless (assoc-default "org" package-archives)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))

  (eval-when-compile
    (unless package--initialized (package-initialize))
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    )
#+END_SRC

* Defaults
** global
#+BEGIN_SRC emacs-lisp
  (setq
   inhibit-startup-screen t
   x-select-enable-clipboard t

   ;; Save whatever’s in the current (system) clipboard before
   ;; replacing it with the Emacs’ text.
   ;; https://github.com/dakrone/eos/blob/master/eos.org
   save-interprogram-paste-before-kill t

   column-number-mode t

   ;; faster scrolling (see https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746)
   auto-window-vscroll nil

   ;; scroll line by line (https://www.gnu.org/software/emacs/manual/html_node/efaq/Scrolling-only-one-line.html)
   scroll-conservatively most-positive-fixnum

   tab-stop-list (number-sequence 2 120 2))
  ;; relative line numbers
  ;; The problem with 'visual is that it does not play very nice with
  ;; visual-fill-column, because it shows a line number for a wrapped line.
  ;; The problem with 'relative is, that it does not work for folded org-mode headers.
  ;;(setq-default display-line-numbers 'visual)
  (setq-default display-line-numbers nil)
  ;; make current line 0
  (setq display-line-numbers-current-absolute nil)
  (setq display-line-numbers-widen t)
  (setq-default fill-column 80)
  (setq-default truncate-lines nil) ; line wrap
  (setq-default indent-tabs-mode nil
                tab-width 2)
  (defvaralias 'c-basic-offset 'tab-width)
  ;; the blinking cursor is nothing, but an annoyance
  (blink-cursor-mode -1)
  (setq-default
   indicate-buffer-boundaries nil  ; don't show where buffer starts/ends
   indicate-empty-lines nil        ; don't show empty lines
   fringes-outside-margins t       ; switches order of fringe and margin
   ;; Keep cursors and highlights in current window only
   cursor-in-non-selected-windows nil
   highlight-nonselected-windows nil
   ;; Disable bidirectional text support for slight performance bonus
   bidi-display-reordering nil
   bidi-paragraph-direction nil
   ;; Remove continuation arrow on right fringe
   ;; fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
   ;;                              fringe-indicator-alist)
   blink-matching-paren nil ; don't blink--too distracting
   ;;show-trailing-whitespace t ;; show trailing whitespace
   )
   ;; turn off ad-redefinition warnings
  (setq ad-redefinition-action 'accept)
  ;; disable the annoying bell ring
  (setq ring-bell-function 'ignore)
  ;; reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  ;; (setq gc-cons-threshold 50000000)
  ;; enable y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; revert buffers automatically when underlying files are changed externally
  (global-auto-revert-mode t)
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (global-hl-line-mode t) ;; highlight current line
#+END_SRC
** flyspell
#+BEGIN_SRC emacs-lisp
  ;;(use-package auto-dictionary :init (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode 1))))
  (setq-default ispell-really-hunspell t)
  (setq-default ispell-program-name "hunspell")

  ;; you could set `ispell-dictionary` instead but `ispell-local-dictionary' has higher priority
  (setq ispell-local-dictionary "en_US")

  ;; use the hunspell -d flag to add more dictionaries
  (setq ispell-local-dictionary-alist
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US,de_AT") nil utf-8)))

  (use-package flyspell
    :init
    ;; to slow for magit commit for example:
    ;;(add-hook 'flyspell-mode-hook #'flyspell-buffer)
    ;; didn't work with magit commit? why?
    ;;(add-hook 'text-mode-local-vars-hook #'flyspell-mode)
    ;;(add-hook 'prog-mode-local-vars-hook #'flyspell-prog-mode)
    (add-hook 'text-mode-hook #'flyspell-mode)
    (add-hook 'prog-mode-hook #'flyspell-prog-mode)
    ;; printing messages for every word (when checking the entire buffer)
    ;; causes an enormous slowdown, thats why I deactivated it:
    (setq flyspell-issue-message-flag nil)
    )
#+END_SRC
** Backups
#+BEGIN_SRC emacs-lisp
  (setq
   make-backup-files t
   version-control t   ; use numbers for backup files
   kept-new-versions 10
   kept-old-versions 0
   delete-old-versions t
   backup-by-copying t
   vc-make-backup-files t
   auto-save-default nil
   backup-directory-alist '(("." . "~/.emacs.d/backup")))
#+END_SRC
** Disable Lockfiles
These are the Files creating in the current Directory for files that have not been saved yet #File#
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC
** Custom File
#+begin_src emacs-lisp
  ;; Don't litter my init file
  (setq custom-file "~/.emacs.d/local/custom-set.el")
  (load custom-file 'noerror)
#+END_SRC
** Encryption
#+BEGIN_SRC emacs-lisp
  (require 'epa-file)
  (epa-file-enable)
#+END_SRC
** MacOS
#+BEGIN_SRC emacs-lisp
  (setq mac-option-modifier nil)
  (setq mac-command-modifier 'meta)
#+END_SRC
* ediff
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC
* GUI
** internal border
#+BEGIN_SRC emacs-lisp
  (set-frame-parameter nil 'internal-border-width 3)
#+END_SRC
** font
#+BEGIN_SRC emacs-lisp
  ;;(set-default-font "Iosevka-12:spacing=110")
  (add-to-list 'default-frame-alist '(font . "Iosevka:pixelsize=14"))
#+END_SRC
** disable menubar
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode 0)
  (tool-bar-mode -1)     ; disable the tool-bar
  (menu-bar-mode -1)     ; disable the menu-bar
  (show-paren-mode)
  ;;(electric-pair-mode 1)

;;; Transparent titlebar
;; https://github.com/d12frosted/homebrew-emacs-plus/blob/master/Formula/emacs-plus.rb#L98
;; https://github.com/d12frosted/homebrew-emacs-plus/issues/55
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Properties-in-Mode.html#Properties-in-Mode
(when (memq window-system '(mac ns))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))

(setq frame-title-format "%b")

#+END_SRC
** fringe
#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'tilde [64 168 16] nil nil 'center)
  (set-fringe-bitmap-face 'tilde 'fringe)
#+END_SRC
** Themes
#+begin_src emacs-lisp
  (use-package challenger-deep-theme
    :ensure t
    :init (load-theme 'challenger-deep t)
    :config
    (set-face-attribute 'org-level-1 nil :background "#2b2942")
    (set-face-attribute 'org-level-2 nil :background "#2b2942" :foreground (face-attribute 'warning :foreground))
    (set-face-attribute 'org-level-3 nil :background "#2b2942" :foreground (face-attribute 'error :foreground))
    (set-face-attribute 'org-level-4 nil :background "#2b2942" :foreground (face-attribute 'success :foreground))
    (set-face-attribute 'org-level-5 nil :background "#2b2942" :foreground (face-attribute 'org-special-keyword :foreground))
    (set-face-attribute 'org-level-6 nil :background "#2b2942" :foreground (face-attribute 'org-table :foreground)))

  (use-package all-the-icons
    :config
    ;; org-mode ellipsis
    (setq-default org-ellipsis (concat " " (all-the-icons-faicon "angle-down") " ")))

  (use-package all-the-icons-dired
    :after (all-the-icons)
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+end_src
* custom Functions
** local abbrev
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.emacs.abbreviations\\'" . emacs-lisp-mode))

  (setq
   global-abbrev-file-name "~/.emacs.d/.emacs.abbreviations"
   abbrev-file-name "~/.emacs.d/.emacs.abbreviations")

  ;; because the local abbrev functions depend on projectile and are only useful
  ;; when projectile is loaded
  (with-eval-after-load "projectile"

    (defun my/save-abbrevs ()
      (interactive)
      (write-abbrev-file))

    (defun my/reload-abbrevs ()
      (interactive)
      (message "Reloading abbrevs from %s" global-abbrev-file-name)
      (quietly-read-abbrev-file global-abbrev-file-name)
      (message "Loaded global abbrevs")
      (if (projectile-project-p)
          (let ((project-abbrevs-file (my/get-local-abbrev-file-name)))
            (message "Loading local abbrevs")
            (when (file-exists-p project-abbrevs-file)
              (quietly-read-abbrev-file project-abbrevs-file)))
        (message "No local abbrevs file to load")
        ))

    (defun my/get-local-abbrev-file-name ()
      (concat (projectile-project-root) ".emacs.abbreviations"))


    (defun my/edit-local-abbrevs ()
      (interactive)
      (message "Clearing tables")
      (mapcar (lambda (table) (clear-abbrev-table (symbol-value table))) abbrev-table-name-list)
      (message "Loading local abbrevs only")
      (when (file-exists-p (my/get-local-abbrev-file-name))
        (quietly-read-abbrev-file (my/get-local-abbrev-file-name)))
      (message "Editing loaded abbrevs")
      (edit-abbrevs)
      (advice-add 'edit-abbrevs-redefine :after 'my/edit-abbrevs-redefine-local-after-advice))

    (defun my/edit-abbrevs-redefine-global-after-advice ()
      (message "Writing global abbrevs")
      (write-abbrev-file)
      (advice-remove 'edit-abbrevs-redefine 'my/edit-abbrevs-redefine-global-after-advice)
      (my/reload-abbrevs))

    (defun my/edit-abbrevs-redefine-local-after-advice ()
      (message "Writing local abbrevs")
      (write-abbrev-file (my/get-local-abbrev-file-name))
      (advice-remove 'edit-abbrevs-redefine 'my/edit-abbrevs-redefine-local-after-advice)
      (my/reload-abbrevs))

    (defcustom abbrev-additional-chars
      '((t ?-))
      "Alist that maps major mode symbols to lists of characters that may appear in abbreviations.
    The chars of the special major mode symbol `t' are active in all modes."
      :group 'abbrev
      :type '(repeat :tag "List of modes"
                     (cons :tag "Map major mode symbols to lists of additional chars in abbrevs"
                           (symbol :tag "Mode symbol (`t' stands for all modes)")
                           (repeat :tag "List of additional word-consistent characters" character))))

    (defvar-local T-abbrev-syntax-table nil
      "List of additional characters in abbreviations.")

    (defun T-abbrev-mode-hook-fun ()
      "Populate T-abbrev-syntax-table with the local syntax table modfied by
    the characters in `abbrev-additional-chars'."
      (when abbrev-mode
        (message "abbrev-mode active, building char-list")
        (let ((char-list (append (cdr (assoc major-mode abbrev-additional-chars))
                                 (cdr (assoc 't abbrev-additional-chars)))))
          (message "creating normal syntax table")
          (setq T-abbrev-syntax-table (make-syntax-table (syntax-table)))
          (message "extending syntax table")
          (mapcar (lambda (char)
                    (message "Adding entry for '%c'" char)
                    (modify-syntax-entry char "w" T-abbrev-syntax-table))
                  char-list))
        (my/reload-abbrevs)))

    ;; Wrapping functions of the `abbrev` package with the local syntax table.
    ;; I'm not sure I captured all fun's that need to run with the local syntax-table.
    ;; Adding further functions is easy.
    ;; Just add them to the list at the end of the next form.
    (mapcar
     (lambda (fun)
       (let ((newfun (intern (concat "T-ad-" (symbol-name fun)))))
         (eval
          `(progn
             (defun ,newfun (oldfun &rest args)
               ,(concat "This function evaluates `" (symbol-name fun) "' with `T-abbrev-syntax-table' as active syntax table.
    It is used for the advicing `" (symbol-name fun) "'.")
               (if T-abbrev-syntax-table
                   (with-syntax-table T-abbrev-syntax-table
                     (apply oldfun args))
                 (apply oldfun args)))
             (advice-add (quote ,fun) :around (quote ,newfun))))))
     '(define-mode-abbrev abbrev--before-point))

    (defun my/abbrev-mode-on ()
      (abbrev-mode 1))

    (add-hook 'abbrev-mode-hook #'T-abbrev-mode-hook-fun)
    (add-hook 'prog-mode-hook #'my/abbrev-mode-on)
    (add-hook 'projectile-after-switch-project-hook #'my/reload-abbrevs))
#+end_src

#+BEGIN_SRC emacs-lisp
  (defconst org-config-file "~/.emacs.d/config.org")
  (defun my-funcs/reload-dotfile ()
    "Reload '~/.emacs.d/init.el'."
    (interactive)
    (load-file "~/.emacs.d/init.el"))
  (defun my-funcs/open-dotfile ()
    "Open '~/.emacs.d/config.org."
    (interactive)
    (find-file org-config-file))
  (defun my-funcs/open-snippet-dir ()
    (interactive)
    (let* ((dir (file-name-as-directory (car yas-snippet-dirs)))
           (path (concat dir (symbol-name major-mode))))
      (dired path)))
  (defun my-funcs/flash-region (start end)
    "Makes the region between START and END change color for a moment"
    (let ((overlay (make-overlay start end)))
      (overlay-put overlay 'face 'swiper-match-face-4)
      (run-with-timer 0.2 nil 'delete-overlay overlay)))
  (defun my-funcs/what-face (pos)
    "Tells you the name of the face (point) is on."
    (interactive "d")
    (let ((hl-line-p (bound-and-true-p hl-line-mode)))
      (if hl-line-p (hl-line-mode -1))
      (let ((face (or (get-char-property (point) 'read-face-name)
                      (get-char-property (point) 'face))))
        (if face (message "Face: %s" face) (message "No face at %d" pos)))
      (if hl-line-p (hl-line-mode 1))))

  (defun sudo-edit (&optional arg)
    "Edit currently visited file as root.
     With a prefix ARG prompt for a file to visit.
     Will also prompt for a file to visit if current
     buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+END_SRC
* dir-locals hook
#+begin_src emacs-lisp
(defun run-local-vars-mode-hook ()
  "Run a hook for the major-mode after the local variables have been processed."
  (run-hooks (intern (format "%S-local-vars-hook" major-mode))))
(add-hook 'hack-local-variables-hook #'run-local-vars-mode-hook)
#+end_src
** Session save/restore
#+BEGIN_SRC emacs-lisp
  (require 'desktop)
  (defvar my-desktop-session-dir
    (concat (getenv "HOME") "/.emacs.d/desktop/")
    "*Directory to save desktop sessions in")
  (defvar my-desktop-session-name-hist nil
    "Desktop session name history")
  (defun my-desktop-save (&optional name)
    "Save desktop by name."
    (interactive)
    (unless name
      (setq name (my-desktop-get-session-name "Save session" t)))
    (when name
      (make-directory (concat my-desktop-session-dir name) t)
      (desktop-save (concat my-desktop-session-dir name) t)))
  (defun my-desktop-save-and-clear ()
    "Save and clear desktop."
    (interactive)
    (call-interactively 'my-desktop-save)
    (desktop-clear)
    (setq desktop-dirname nil))
  (defun my-desktop-read (&optional name)
    "Read desktop by name."
    (interactive)
    (unless name
      (setq name (my-desktop-get-session-name "Load session")))
    (when name
      (desktop-clear)
      (desktop-read (concat my-desktop-session-dir name))))
  (defun my-desktop-change (&optional name)
    "Change desktops by name."
    (interactive)
    (let ((name (my-desktop-get-current-name)))
      (when name
        (my-desktop-save name))
      (call-interactively 'my-desktop-read)))
  (defun my-desktop-name ()
    "Return the current desktop name."
    (interactive)
    (let ((name (my-desktop-get-current-name)))
      (if name
          (message (concat "Desktop name: " name))
        (message "No named desktop loaded"))))
  (defun my-desktop-get-current-name ()
    "Get the current desktop name."
    (when desktop-dirname
      (let ((dirname (substring desktop-dirname 0 -1)))
        (when (string= (file-name-directory dirname) my-desktop-session-dir)
          (file-name-nondirectory dirname)))))
  (defun my-desktop-get-session-name (prompt &optional use-default)
    "Get a session name."
    (let* ((default (and use-default (my-desktop-get-current-name)))
           (full-prompt (concat prompt (if default
                                           (concat " (default " default "): ")
                                         ": "))))
      (completing-read full-prompt (and (file-exists-p my-desktop-session-dir)
                                        (directory-files my-desktop-session-dir))
                       nil nil nil my-desktop-session-name-hist default)))
  (defun my-desktop-kill-emacs-hook ()
    "Save desktop before killing emacs."
    (when (file-exists-p (concat my-desktop-session-dir "last-session"))
      (setq desktop-file-modtime
            (nth 5 (file-attributes (desktop-full-file-name (concat my-desktop-session-dir "last-session"))))))
    (my-desktop-save "last-session"))
  (add-hook 'kill-emacs-hook 'my-desktop-kill-emacs-hook)
#+END_SRC
* Evil
** initialize
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration nil)
    (setq evil-want-keybinding nil)

    ;; whichwrap like movement across lines
    (setq-default evil-cross-lines t)
    (setq-default evil-search-module 'evil-search
                  evil-want-abbrev-expand-on-insert-exit nil
                  evil-ex-substitute-global t ;; make substitue global by default
                  evil-shift-width 2
                  ;; prevent esc-key from translating to meta-key in terminal mode
                  evil-esc-delay 0
                  evil-want-Y-yank-to-eol t)
    (evil-mode t)
    :config
    (evil-set-initial-state 'package-menu-mode 'normal)
    (evil-set-initial-state 'help-mode 'normal)
    (evil-set-initial-state 'ibuffer-mode 'normal)
    ;;(evil-set-initial-state 'pdf-view-mode 'normal)
    (evil-set-initial-state 'ivy-occur-grep-mode 'normal)
    (evil-set-initial-state 'occur-mode 'normal)
    ;;(setq evil-emacs-state-modes nil)
    ;;(setq evil-insert-state-modes nil)
    ;;(setq evil-motion-state-modes nil)

    ;;Evil smartparens text objects
    (evil-define-text-object evil-a-sexp (count &optional beg end type)
      "outer sexp"
      (evil-range (progn
                    (save-excursion
                      (sp-beginning-of-sexp)
                      (- (point) 1)))
                  (progn
                    (save-excursion
                      (sp-end-of-sexp)
                      (+ (point) 1)))))
    (define-key evil-outer-text-objects-map "f" 'evil-a-sexp)
    (evil-define-text-object evil-i-sexp (count &optional beg end type)
      "inner sexp"
      (evil-range (progn
                    (save-excursion
                      (sp-beginning-of-sexp)
                      (point)))
                  (progn
                    (save-excursion
                      (sp-end-of-sexp)
                      (point)))))
    (define-key evil-inner-text-objects-map "f" 'evil-i-sexp)
    (evil-define-text-object evil-a-top-level-sexp (count &optional beg end type)
      "outer top level sexp"
      (evil-range (progn
                    (save-excursion
                      (beginning-of-defun)
                      (- (point) 1)))
                  (progn
                    (save-excursion
                      (end-of-defun)
                      (+ (point) 1)))))
    (define-key evil-outer-text-objects-map "F" 'evil-a-top-level-sexp)
    (evil-define-text-object evil-i-top-level-sexp (count &optional beg end type)
      "inner top level sexp"
      (evil-range (progn
                    (save-excursion
                      (beginning-of-defun)
                      (point)))
                  (progn
                    (save-excursion
                      (end-of-defun)
                      (point)))))
    (define-key evil-inner-text-objects-map "F" 'evil-i-top-level-sexp)
    (evil-define-text-object evil-a-lisp-element (count &optional beg end type)
      "outer sexp"
      (evil-range (progn
                    (save-excursion
                      ;;TODO
                      ))
                  (progn
                    (save-excursion
                      ;;TODO
                      ))))
    ;;(define-key evil-outer-text-objects-map "e" 'evil-a-lisp-element)
    (evil-define-text-object evil-i-lisp-element (count &optional beg end type)
      "inner sexp"
      (evil-range (progn
                    (save-excursion
                      ;;TODO
                      ))
                  (progn
                    (save-excursion
                      ;;TODO
                      ))))
    ;;(define-key evil-inner-text-objects-map "e" 'evil-i-lisp-element)

    (evil-define-text-object evil-i-line (count &optional beg end type)
      "inner line"
      (evil-range (progn
                    (save-excursion
                      (back-to-indentation)
                      (point)))
                  (progn
                    (save-excursion
                      (end-of-line)
                      (point)))))
    (define-key evil-inner-text-objects-map "l" 'evil-i-line)
    (evil-define-text-object evil-a-line (count &optional beg end type)
      "outer line"
      (evil-range (progn
                    (save-excursion
                      (evil-beginning-of-line)
                      (point)))
                  (progn
                    (save-excursion
                      (end-of-line)
                      (point)))))
    (define-key evil-outer-text-objects-map "l" 'evil-a-line)

  (evil-define-operator evil-eval-elisp-text-object (beg end)
    "Evil operator for evaluating code."
    :move-point nil
    (save-excursion
      (let (eval-str
            value)
        (setq eval-str (buffer-substring beg end))
        (setq value (eval (car (read-from-string eval-str)) lexical-binding))
        (my-funcs/flash-region beg end)
        (my-funcs/eval-overlay value end)
        (message (format "%s" value)))))

  (evil-define-operator evil-narrow-indirect (beg end type)
    "Indirectly narrow the region from BEG to END."
    (interactive "<R>")
    (narrow-to-region-indirect beg end)))
#+end_src
** evil-collection
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :after evil
    :init
    ;; disable company tng (to be able to complete with rtn)
    (setq evil-collection-company-use-tng nil)
    (require 'evil-collection)
     ;; edebug mode clashes with helpful.
    (setq evil-collection-mode-list (delete 'edebug evil-collection-mode-list))
    :config
    ;;(setq evil-collection-mode-list ...)
    ;; These are the mappings i use for window management and i don't want
    ;; evil-collection to override those
    (defun my-evil-collection-key-setup (_mode mode-keymaps &rest _rest)
      (evil-collection-translate-key 'normal mode-keymaps
        (kbd "SPC") nil
        (kbd "gj") nil ;; outline mode would rebind gj
        (kbd "gk") nil ;; outline mode would rebind gj
        ))
    ;; called after evil-collection makes its keybindings
    (add-hook 'evil-collection-setup-hook #'my-evil-collection-key-setup)

    (evil-collection-init)

    )
#+END_SRC
** snippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :init
    (yas-global-mode 1))
#+END_SRC
** default-text-scale
#+BEGIN_SRC emacs-lisp
  (use-package default-text-scale
  :after (hydra)
  :init
  (defhydra hydra-zoom ()
      "Zoom"
      ("u" default-text-scale-reset"unzoom")
      ("i" text-scale-increase "in Buffer")
      ("I" default-text-scale-increase "in Frame")
      ("O" default-text-scale-decrease "out Frame")
      ("o" text-scale-decrease "out Buffer")))
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :config
    (defhydra hydra-window-resize ()
      "Window resizing"
      ("j" my-funcs/resize-window-down "down")
      ("k" my-funcs/resize-window-up "up")
      ("l" my-funcs/resize-window-right "right")
      ("h" my-funcs/resize-window-left "left")))
  (defhydra hydra-projectile (:color teal :columns 4)
    "Projectile"
    ("f"   projectile-find-file                "Find File")
    ("r"   projectile-recentf                  "Recent Files")
    ("z"   projectile-cache-current-file       "Cache Current File")
    ("x"   projectile-remove-known-project     "Remove Known Project")
    ("d"   projectile-find-dir                 "Find Directory")
    ("b"   projectile-switch-to-buffer         "Switch to Buffer")
    ("c"   projectile-invalidate-cache         "Clear Cache")
    ("X"   projectile-cleanup-known-projects   "Cleanup Known Projects")
    ("o"   projectile-multi-occur              "Multi Occur")
    ("p"   projectile-switch-project           "Switch Project")
    ("k"   projectile-kill-buffers             "Kill Buffers")
    ("q"   nil "Cancel" :color blue))
#+END_SRC
** define lisp modes
#+BEGIN_SRC emacs-lisp
  (setq lisp-modes '(clojure-mode
                     clojurescript-mode
                     lisp-interaction-mode
                     cider-repl-mode
                     emacs-lisp-mode))

  (setq lisp-mode-maps (mapcar (lambda (mode)
                                 (intern (concat (symbol-name mode) "-map")))
                               lisp-modes))
#+END_SRC
** General (keybindings)
[[https://github.com/noctuid/general.el][general.el]]
#+BEGIN_SRC emacs-lisp
  (use-package general
    :after (evil)
    :config
    (setq general-override-states '(insert
                                    emacs
                                    hybrid
                                    normal
                                    visual
                                    motion
                                    operator
                                    replace))
    (general-override-mode)
    ;;(general-evil-setup)
    ;; bind a key globally in normal state; keymaps must be quoted
    (setq general-default-keymaps 'evil-normal-state-map)

    ;; named prefix key
    (setq my-leader "SPC")
    (setq my-leader2 ",")
    (setq local-leader "\\")

    (general-define-key
     :states 'normal
     :keymaps 'override
     "gf" 'counsel-find-file
     "gS" 'my-funcs/open-snippet-dir
     "zw" 'widen
     "s" 'save-buffer
     "S" 'projectile-find-file
     ;; to jump to next enxty in ivy occur
     "] n" 'ivy-occur-next-line
     "[ n" 'ivy-occur-previous-line
     "g s" 'magit-status
     "g G" (lambda ()
             (interactive)
             (evil-ex (concat "g/" (evil-get-register ?/) "/")))
     "`" 'evil-goto-mark-line
     "'" 'evil-goto-mark
     "g ." 'my-funcs/open-dotfile
     "g p" 'counsel-yank-pop
     "Q" 'org-capture
     "g i" (lambda ()
             (interactive)
             (find-file (concat org-directory "/inbox.org")))
     "g o" (lambda ()
             (interactive)
             (counsel-find-file org-directory)))
    (general-define-key
     :states 'normal
     :keymaps 'override
     :prefix my-leader
     ;;"r" 'restart-emacs
     "a" 'org-agenda
     "p" 'hydra-projectile/body
     "q" 'evil-window-delete
     "k" 'kill-buffer
     "D" 'evil-delete-buffer
     "d" 'kill-this-buffer
     "r" (lambda ()
           (interactive)
           (evil-ex (concat "%s/" (evil-get-register ?/) "/")))

     "SPC" 'ace-select-window
     "s" 'dumb-jump-go
     "S" 'dumb-jump-go-prompt
     ;;"h" (general-simulate-keys "C-h")
     "h k" 'helpful-key
     "h SPC" 'which-key-show-top-level
     "h v" 'helpful-variable
     "h f" 'helpful-function
     "h m" 'describe-mode
     "<return>" 'my/projectile-multi-term
     "S-<return>" 'multi-term
     ;;  Avoiding CTRL
     "w" (general-simulate-key "C-w")
     "x" (general-simulate-key "C-x")
     "c" (general-simulate-key "C-c")
     "i" 'ibuffer
     "j" 'projectile-find-file
     "/" 'counsel-rg-project
     "e" 'projectile-switch-to-buffer
     "g s" 'git-gutter:stage-hunk
     "g t" 'git-timemachine
     "g n" 'git-gutter:next-hunk
     "g p" 'git-gutter:previous-hunk
     "g r" 'git-gutter:revert-hunk
     "g p" 'git-gutter:popup-hunk
     "l" 'evil-avy-goto-line
     "u" 'undo-tree-visualize
     "f" 'counsel-find-file
     "b" 'ivy-switch-buffer
     "n" 'next-error
     "N" 'previous-error
     "z" 'hydra-zoom/body
     "o" 'dired-jump
     "O" 'dired)

    (general-define-key
     :states '(operator normal visual)
     :keymaps 'override
     :prefix my-leader2
     "," 'evil-repeat-find-char-reverse)

    (general-define-key
     :states '(operator normal visual)
     :keymaps 'override
     "gf" 'evil-avy-goto-char
     "gl" 'evil-avy-goto-line
     "gW" 'evil-avy-goto-word-1)
    )

#+END_SRC
** move-text
#+begin_src emacs-lisp
  (use-package move-text
    :general
    (:keymaps 'normal
     "] e" 'move-text-down
     "[ e" 'move-text-up))
#+end_src
** evil-surround
#+begin_src emacs-lisp
    (use-package evil-surround
      :after (evil)
      :init
      (global-evil-surround-mode))
#+end_src
** aggressive indent
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :config)
#+end_src
** evil-expat (extra ex-commands)
#+begin_src emacs-lisp
(use-package evil-expat
  ;; optional, defer loading until 1 second of inactivity,
  ;; hence not affecting emacs startup time
  :defer 1)
#+end_src
** evil-args
#+begin_src emacs-lisp
  (use-package evil-args
    :after (evil)
    :config
    ;; bind evil-args text objects
    (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
    (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
    )
#+end_src
** evil-lion
#+begin_src emacs-lisp
(use-package evil-lion
  :after (evil)
  :init
  (evil-lion-mode))
#+end_src
** evil-indent-plus textobject
- ii: A block of text with the same or higher indentation.
- ai: The same as ii, plus whitespace.
- iI: A block of text with the same or higher indentation, including the first line above with less indentation.
- aI: The same as iI, plus whitespace.
- iJ: A block of text with the same or higher indentation, including the first line above and below with less indentation.
- aJ: The same as iJ, plus whitespace.
#+begin_src emacs-lisp
  (use-package evil-indent-plus
    :after (evil)
    :init
    ;; bind evil-indent-plus text objects
    (evil-indent-plus-default-bindings)
    )
#+end_src
** evil-numbers
increment and decrement numbers with c-a and c-x
#+begin_src emacs-lisp
    (use-package evil-numbers
      :after (evil)
      :commands (evil-numbers/inc-at-pt evil-numbers/dec-at-pt)
      :init
      (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
      (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt))
#+end_src
** evil-matchit
% to jump between matched tags
#+begin_src emacs-lisp
    (use-package evil-matchit
      :after (evil)
      :init
      (global-evil-matchit-mode 1))
#+end_src
** evil-quickscope
#+BEGIN_SRC emacs-lisp
  (use-package evil-quickscope
    :init
    (global-evil-quickscope-mode 1))
#+END_SRC
** evil-exchange
#+begin_src emacs-lisp
     ;;cx to mark exchange second time to do it
     ;;cxc to cancel
    (use-package evil-exchange
      :commands (evil-exchange)
      :init
      (evil-exchange-cx-install))
#+end_src
** evil-nerd-commenter
#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :after general
    :demand t
    :init
    (general-define-key
     :states 'normal
     :keymaps 'override
     "gc" 'evilnc-comment-operator))
#+end_src
** evil-anzu
provides a minor mode which displays current match and total matches 
#+begin_src emacs-lisp
  (use-package evil-anzu
      :after (evil)
      :init
      (require 'evil-anzu))
#+end_src
** evil-owl
view your registers and marks in a posframe before using them
#+begin_src emacs-lisp
  (use-package evil-owl
    :config
    (setq evil-owl-extra-posframe-args '(:width 50 :height 20)
          evil-owl-register-char-limit 50)
    :init
    (evil-owl-mode))
#+end_src
** evil textobject-to-search
#+begin_src emacs-lisp
(evil-define-operator evil-search-textobject (beg end)
  "Evil operator for evaluating code."
  :move-point nil
  (let ((textobj-str (buffer-substring beg end)))
    (setq evil-ex-search-pattern (evil-ex-make-pattern textobj-str t t))
    (evil-ex-search-activate-highlight evil-ex-search-pattern)
    ;; update search history unless this pattern equals the
    ;; previous pattern
    (unless (equal (car-safe evil-ex-search-history) textobj-str)
      (push textobj-str evil-ex-search-history))
    (evil-push-search-history textobj-str t)
    (goto-char beg)))


    (general-def 'normal 'override
      "g/" 'evil-search-textobject)
#+end_src
** ibuffer
#+begin_src emacs-lisp
  (defhydra hydra-ibuffer-main (:color pink :hint nil)
    "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
    _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
    ("j" ibuffer-forward-line)
    ("RET" ibuffer-visit-buffer :color blue)
    ("k" ibuffer-backward-line)
    ("m" ibuffer-mark-forward)
    ("u" ibuffer-unmark-forward)
    ("*" hydra-ibuffer-mark/body :color blue)
    ("D" ibuffer-do-delete)
    ("S" ibuffer-do-save)
    ("a" hydra-ibuffer-action/body :color blue)
    ("g" ibuffer-update)
    ("s" hydra-ibuffer-sort/body :color blue)
    ("/" hydra-ibuffer-filter/body :color blue)
    ("q" ibuffer-quit "quit ibuffer" :color blue))
  (defhydra hydra-ibuffer-mark (:color teal :columns 5
                                :after-exit (hydra-ibuffer-main/body))
    "Mark"
    ("*" ibuffer-unmark-all "unmark all")
    ("M" ibuffer-mark-by-mode "mode")
    ("m" ibuffer-mark-modified-buffers "modified")
    ("u" ibuffer-mark-unsaved-buffers "unsaved")
    ("s" ibuffer-mark-special-buffers "special")
    ("r" ibuffer-mark-read-only-buffers "read-only")
    ("/" ibuffer-mark-dired-buffers "dired")
    ("e" ibuffer-mark-dissociated-buffers "dissociated")
    ("h" ibuffer-mark-help-buffers "help")
    ("z" ibuffer-mark-compressed-file-buffers "compressed")
    ("b" hydra-ibuffer-main/body "back" :color blue))
  (defhydra hydra-ibuffer-action (:color teal :columns 4
                                  :after-exit
                                  (if (eq major-mode 'ibuffer-mode)
                                      (hydra-ibuffer-main/body)))
    "Action"
    ("A" ibuffer-do-view "view")
    ("E" ibuffer-do-eval "eval")
    ("F" ibuffer-do-shell-command-file "shell-command-file")
    ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
    ("H" ibuffer-do-view-other-frame "view-other-frame")
    ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
    ("M" ibuffer-do-toggle-modified "toggle-modified")
    ("O" ibuffer-do-occur "occur")
    ("P" ibuffer-do-print "print")
    ("Q" ibuffer-do-query-replace "query-replace")
    ("R" ibuffer-do-rename-uniquely "rename-uniquely")
    ("T" ibuffer-do-toggle-read-only "toggle-read-only")
    ("U" ibuffer-do-replace-regexp "replace-regexp")
    ("V" ibuffer-do-revert "revert")
    ("W" ibuffer-do-view-and-eval "view-and-eval")
    ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
    ("b" nil "back"))
  (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
    "Sort"
    ("i" ibuffer-invert-sorting "invert")
    ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
    ("v" ibuffer-do-sort-by-recency "recently used")
    ("s" ibuffer-do-sort-by-size "size")
    ("f" ibuffer-do-sort-by-filename/process "filename")
    ("m" ibuffer-do-sort-by-major-mode "mode")
    ("b" hydra-ibuffer-main/body "back" :color blue))
  (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
    "Filter"
    ("m" ibuffer-filter-by-used-mode "mode")
    ("M" ibuffer-filter-by-derived-mode "derived mode")
    ("n" ibuffer-filter-by-name "name")
    ("c" ibuffer-filter-by-content "content")
    ("e" ibuffer-filter-by-predicate "predicate")
    ("f" ibuffer-filter-by-filename "filename")
    (">" ibuffer-filter-by-size-gt "size")
    ("<" ibuffer-filter-by-size-lt "size")
    ("/" ibuffer-filter-disable "disable")
    ("b" hydra-ibuffer-main/body "back" :color blue))
  (general-define-key :keymaps '(ibuffer-mode-map)
                      :states '(normal)
                      "SPC" 'hydra-ibuffer-main/body
                      "j" 'ibuffer-forward-line
                      "k" 'ibuffer-backward-line
                      "J" 'ibuffer-jump-to-buffer)
#+end_src
** help
#+begin_src emacs-lisp
  (general-define-key :keymaps '(help-mode-map)
                      :states '(normal)
                      "C-o" 'help-go-back
                      "C-i" 'help-go-forward
                      "r" 'help-follow
                      "q" 'quit-window)
#+end_src
** package-menu
#+begin_src emacs-lisp
  (setq package-menu-async t)
  (general-define-key :keymaps '(package-menu-mode-map)
                      :states '(normal)
                      "i" 'package-menu-mark-install
                      "U" 'package-menu-mark-upgrades
                      "d" 'package-menu-mark-delete

                      ;; undo
                      "u" 'package-menu-mark-unmark

                      ;; execute
                      "x" 'package-menu-execute
                      ;; "q" 'quit-window ; macros can make sense here.
                      "ZQ" 'evil-quit
                      "ZZ" 'quit-window)
#+end_src
** evil-replace-with-register
#+begin_src emacs-lisp
  (use-package evil-replace-with-register
    :after (evil)
    :init
    (setq evil-replace-with-register-key (kbd "gr"))
    (evil-replace-with-register-install))
#+end_src
** artist-mode
#+begin_src emacs-lisp
(add-hook 'artist-mode-hook #'(lambda () (evil-emacs-state)))
#+end_src
** abbrev
#+begin_src emacs-lisp
(setq-default
 abbrev-mode t)
#+end_src
** company-mode
#+begin_src emacs-lisp
  (use-package company
   :init
   (setq company-idle-delay 0.2
         company-minimum-prefix-length 2
         company-require-match nil
         company-selection-wrap-around t
         company-dabbrev-ignore-case nil
         company-dabbrev-downcase nil)

   (global-company-mode)
   (define-key company-active-map [tab] 'company-complete)
   (define-key company-active-map (kbd "C-n") 'company-select-next)
   (define-key company-active-map (kbd "C-p") 'company-select-previous))

   (use-package company-box :hook (company-mode . company-box-mode))
#+end_src
** narrowing
enable narrowing
#+begin_src emacs-lisp
 (put 'narrow-to-defun  'disabled nil)
 (put 'narrow-to-page   'disabled nil)
 (put 'narrow-to-region 'disabled nil)
#+end_src
#+begin_src emacs-lisp
  (defun narrow-to-region-indirect (start end)
    "Restrict editing in this buffer to the current region, indirectly."
    (interactive "r")
    (deactivate-mark)
    (let ((buf (clone-indirect-buffer nil nil)))
      (with-current-buffer buf
        (narrow-to-region start end))
        (switch-to-buffer buf)))

  (general-define-key
      :states '(normal operator visual)
   :keymaps 'override
   "zn" 'evil-narrow-indirect)
#+end_src
* Package config
** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :general
    (:keymaps 'normal
              "] q" 'flycheck-next-error
              "[ q" 'flycheck-previous-error)
    :after (fringe-helper)
    :init
    (global-flycheck-mode)
    :config
    (setq flycheck-indication-mode 'right-fringe)
    ;; A non-descript, left-pointing arrow
    (fringe-helper-define 'flycheck-fringe-bitmap-double-arrow 'center
      "...X...."
      "..XX...."
      ".XXX...."
      "XXXX...."
      ".XXX...."
      "..XX...."
      "...X....")
    )
#+end_src
** Exec-path
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
      :config
      (when (memq window-system '(mac ns x))
        (exec-path-from-shell-copy-env "PGUSER")
        (exec-path-from-shell-copy-env "PGPASSWORD")
        (exec-path-from-shell-initialize)))
#+END_SRC
** Popup Window
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :init
    (setq shackle-select-reused-windows nil) ; default nil
    (setq shackle-default-alignment 'below) ; default below
    (setq shackle-default-size 0.3) ; default 0.5
    (setq shackle-rules
          '(("*Warnings*"  :size 8  :noselect t)
            ("*Messages*"  :size 12 :noselect t)
            ("*Help*" :select t :align below :inhibit-window-quit nil :modeline nil)
            ("*Metahelp*" :size 0.3 :align left)
            (undo-tree-visualizer-mode :size 0.5 :align right)
            (alchemist-iex-mode :align below)
            (sql-interaction-mode :align below)
            (alchemist-test-report-mode :size 0.4 :align right :noselect t)
            ("*alchemist help*" :select t :align below :inhibit-window-quit nil :modeline nil)
            (magit-status-mode :same t)
            ("*git-gutter:diff*" :same t :inhibit-window-quit t)
            ("*HTTP Response*" :size 0.3 :align below)
            (rg-mode :align below)
            (cider-repl-mode :align below :noselect t)
            (cider-inspector-mode :size 0.3 :align above)
            ("*cider-error*" :size 0.5 :align right)
            (ivy-occur-grep-mode :size 0.3 :align below)
            (flycheck-error-list-mode :select t :autokill t :align below)))
    (shackle-mode 1))
#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp
  (defun my-funcs/eval-overlay (value point)
    (cider--make-result-overlay (format "%S" value)
                                :where point
                                :duration 'command)
    ;; Preserve the return value.
    value)
  (advice-add 'eval-last-sexp :filter-return
              (lambda (r)
                (my-funcs/eval-overlay r (point))))
  (advice-add 'eval-defun :filter-return
              (lambda (r)
                (my-funcs/eval-overlay
                 r
                 (save-excursion
                   (end-of-defun)
                   (point)))))

  (use-package clojure-mode
    :config
    (require 'cider)
    (setq clojure-align-forms-automatically t)
    (put-clojure-indent 'defui '(2 nil nil (1))))

  (use-package flycheck-clj-kondo
    :after clojure-mode
    :init
    (require 'flycheck-clj-kondo))

  ;; (use-package flycheck-joker
  ;;   :init
  ;;   (require 'flycheck-joker)
  ;;   :config
  ;;   (add-to-list 'flycheck-checkers 'clojure-joker t)
  ;;   (add-to-list 'flycheck-checkers 'clojurescript-joker t))

  (use-package clj-refactor
    :init
    (defun my-clj-refactor-mode-hook ()
    (clj-refactor-mode 1))
    (add-hook 'clojure-mode-hook #'my-clj-refactor-mode-hook))
  (use-package cider
    :init
    (add-hook 'clojure-mode-hook 'cider-mode)
    :after (evil general)
    :commands (cider--make-result-overlay)
    :config
    (setq cider-repl-pop-to-buffer-on-connect 'display-only)
    (setq cider-repl-display-in-current-window nil)
    (setq cider-repl-use-pretty-printing t)
    (autoload 'cider--make-result-overlay "cider-overlays")
    (evil-define-operator evil-eval-clojure-text-object (beg end)
      "Evil operator for evaluating code."
      :move-point nil
      (save-excursion
        (my-funcs/flash-region beg end)
        (cider-eval-region beg end)))
    (defun my/goto-or-switch-back-from-repl ()
      (interactive)
      (if (eq major-mode 'cider-repl-mode)
          (cider-switch-to-last-clojure-buffer)
        (cider-switch-to-repl-buffer)))
    (general-define-key
     :states 'normal
     :keymaps '(cider-inspector-mode-map)
      "n" 'cider-inspector-next-page
      "q" 'quit-window
      "N" 'cider-inspector-prev-page
      "RET" 'cider-inspector-operate-on-point
      "d" 'cider-inspector-pop
      "r" 'cider-inspector-refresh)
    (general-def 'normal '(cider-popup-buffer-mode-map cider-stacktrace-mode-map)
      "q" 'cider-popup-buffer-quit)
    (general-def 'normal '(clojure-mode-map cider-repl-mode-map cider-clojure-interaction-mode-map)
      :prefix local-leader
      "r" 'cider-hydra-repl/body
      "j" 'cider-jack-in
      "s" 'cider-jack-in-clojurescript
      "i" 'cider-inspect-last-result
      "g" 'my/goto-or-switch-back-from-repl
      "c" 'cider-jack-in
      "d" 'cider-hydra-doc/body
      "e" 'cider-hydra-eval/body
      "q" 'hydra-cljr-help-menu/body)
    (general-def 'normal '(clojure-mode-map cider-repl-mode-map cider-clojure-interaction-mode-map)
      "c" (general-key-dispatch 'evil-change
            "p" (general-key-dispatch 'evil-eval-clojure-text-object
                  :name general-dispatch-eval-clojure-text-object
                  "p" (lambda ()
                        (interactive)
                        (let* ((range (evil-a-sexp))
                               (beg (elt range 0))
                               (end (elt range 1)))
                          (evil-eval-clojure-text-object beg end))))
            ;; could be used for other operators where there
            ;; isn't an existing command for the linewise version:
            ;; "c" (general-simulate-keys ('evil-change "c"))
            ))
   ;; for some reason the above also overrides visual state
  (general-define-key :states 'visual
                      :keymaps '(clojure-mode-map cider-repl-mode-map cider-clojure-interaction-mode-map)
                      "c" 'evil-change)
    )
  (use-package cider-hydra
    :after (evil clojure-mode)
    :init
    (add-hook 'cider-mode-hook #'cider-hydra-mode))
  :config

#+end_src
** elisp
#+BEGIN_SRC emacs-lisp
  (general-define-key :states 'normal
                      :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
                      "c" (general-key-dispatch 'evil-change
                      :name list-evil-change-dispatch
                            "p" (general-key-dispatch 'evil-eval-elisp-text-object
                                  :name general-dispatch-eval-elisp-text-object
                                  "p" (lambda ()
                                        (interactive)
                                        (let* ((range (evil-a-sexp))
                                               (beg (elt range 0))
                                               (end (elt range 1)))
                                          (evil-eval-elisp-text-object beg end))))))

   ;; for some reason the above also overrides visual state keybindings
  (general-define-key :states 'visual
                      :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
                      "c" 'evil-change)

#+END_SRC
** which-key
#+begin_src emacs-lisp
  (use-package which-key
    :init
    (which-key-mode))
    (use-package which-key-posframe
      :init
      (which-key-posframe-mode))
#+END_SRC
** Fringe helper
#+BEGIN_SRC emacs-lisp
  (use-package fringe-helper
  :demand t)
#+END_SRC
** Git Gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
    :after (fringe-helper)
    :demand t
    :init
    (advice-add 'evil-force-normal-state :after 'git-gutter)
    (add-hook 'focus-in-hook 'git-gutter:update-all-windows)
    :config
    (fringe-mode 3)
    (fringe-helper-define 'git-gutter-fr:added '(center repeated)
      "XXX.....")
    (fringe-helper-define 'git-gutter-fr:modified '(center repeated)
      "XXX.....")
    (fringe-helper-define 'git-gutter-fr:deleted 'bottom
      "X......."
      "XX......"
      "XXX....."
      "XXXX....")
    )
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    (require 'evil-magit)
    (setq magit-diff-refine-hunk (quote all)))
  (use-package evil-magit
    :after (magit)
    :config
    (general-define-key :keymaps '(magit-mode-map)
                        :states '(normal)
                        "C-n" 'magit-section-forward
                        "C-p" 'magit-section-backward)
    )

  (use-package git-timemachine
    :after general
    :config
    (general-define-key :keymaps '(git-timemachine-mode-map)
                        :states '(normal)
                        :prefix my-leader2
                        "n" 'git-timemachine-show-next-revision
                        "p" 'git-timemachine-show-previous-revision
                        "r" 'git-timemachine-show-current-revision
                        "q" 'git-timemachine-quit))
#+END_SRC
** imenu-list (file overview)
#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :config
    (setq imenu-list-focus-after-activation t)
    (setq imenu-list-position 'left)
    (general-define-key :keymaps 'imenu-list-major-mode-map
                        :states '(normal)
                        "|" 'imenu-list-minor-mode
                        "RET" 'imenu-list-goto-entry
                        (kbd "S-<return>") (lambda ()
                                             (interactive)
                                             (imenu-list-goto-entry)
                                             (org-narrow-to-subtree))
                        "i" 'imenu-list-goto-entry
                        "q" 'imenu-list-quit-window))
#+END_SRC
** COMMENT Visual fill Column
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :config
    ;;(setq-default visual-fill-column-center-text t)
    :ghook 'text-mode-hook)
#+END_SRC
** Visual Line Mode
#+BEGIN_SRC emacs-lisp
  ;; soft-wrap lines
  (add-hook 'text-mode-hook #'visual-line-mode)
  ;; show right-curly arrow on right of wrapped lines
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC
** Org Mode
*** init org-mode
Load org-plus-contrib
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib)
#+END_SRC
*** org settings
**** latex syntax highlight
#+BEGIN_SRC emacs-lisp
  (setq org-highlight-latex-and-related '(latex script entities))
#+END_SRC
**** log done date
#+BEGIN_SRC emacs-lisp
  (setq org-log-done t)
#+END_SRC
**** COMMENT org-indent-mode (indent sub-headings)
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
**** use default log drawer
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC
**** adapt indentation
#+BEGIN_SRC emacs-lisp
  (setq org-adapt-indentation nil)
#+END_SRC
**** enable syntax highlighting in org-babel source code
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC
**** set org default directory
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/org/")
        org-directory "~/org/"
        org-archive-location "~/org/archive/%s::")
#+END_SRC
**** org src block indention
#+BEGIN_SRC emacs-lisp
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 2)
#+END_SRC

**** set default output directory (and not use the current directory by default)
#+BEGIN_SRC emacs-lisp
  (defvar-local org-export-output-directory (concat (getenv "HOME") "/Downloads/org-exports") "directory used for org-mode export")

  (defadvice org-export-output-file-name (before org-add-export-dir activate)
    "Modifies org-export to place exported files in a different directory"
    (when (not pub-dir)
      (setq pub-dir org-export-output-directory)
        (when (not (file-directory-p pub-dir))
         (make-directory pub-dir))))

  (setq org-babel-default-header-args:dot `((:results . "file") (:exports . "results") (:dir . ,org-export-output-directory)))
#+END_SRC

**** latex export class book-noparts (skip part in book layout)
#+BEGIN_SRC emacs-lisp
(setq org-latex-caption-above nil)
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
             '("book-noparts"
                "\\documentclass{book}"
                ("\\chapter{%s}" . "\\chapter*{%s}")
                ("\\section{%s}" . "\\section*{%s}")
                ("\\subsection{%s}" . "\\subsection*{%s}")
                ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                ("\\paragraph{%s}" . "\\paragraph*{%s}")
                ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
**** capture templates
#+BEGIN_SRC emacs-lisp
  (defun my/add-org-id (properties)
    (let ((id  ":ID: %(shell-command-to-string \"uuidgen\"):CREATED: %U"))
      (cons id properties)))

  (defun my/properties-list->string (properties)
    (let ((head  "\n:PROPERTIES:"))
      (concat (string-join (cons head properties) "\n")
              "\n:END:")))

  (add-hook 'org-capture-mode-hook 'evil-insert-state)

  (setq org-capture-templates
           `(("i"
              "INBOX"
              entry
              (file "inbox.org")
              ,(concat "* %?" (my/properties-list->string (my/add-org-id nil)))
              :prepend t)
             ("t"
              "INBOX TODO"
              entry
              (file "inbox.org")
              "* TODO %? SCHEDULED: %t")))
     (setq org-refile-use-outline-path 'file)
     (setq org-outline-path-complete-in-steps nil)
     ;; use a depth level of 6 max
     (setq org-refile-targets
           '((org-agenda-files . (:maxlevel . 4))))
     #+END_SRC
**** set inline image background
#+BEGIN_SRC emacs-lisp
  (defcustom org-inline-image-background nil
    "The color used as the default background for inline images.
    When nil, use the default face background."
    :group 'org
    :type '(choice color (const nil)))

    (defun org-display-inline-images--with-color-theme-background-color (args)
      "Specify background color of Org-mode inline image through modify `ARGS'."
      (let* ((file (car args))
             (type (cadr args))
             (data-p (caddr args))
             (props (cdddr args)))
        ;; get this return result style from `create-image'
        (append (list file type data-p)
                ;;(list :background (face-background 'default))
                (list :background org-inline-image-background)
                props)))

    (advice-add 'create-image :filter-args
                #'org-display-inline-images--with-color-theme-background-color)

    (setq org-inline-image-background "#ffffff")
#+END_SRC
**** smart invisible edits (show edits and don't allow deletion)
     #+BEGIN_SRC emacs-lisp
(setq-default org-catch-invisible-edits 'smart)
     #+END_SRC
**** COMMENT hide leading stars
     #+BEGIN_SRC emacs-lisp
(setq-default org-hide-leading-stars t)
     #+END_SRC
*** org-bullets (pretty bullets)
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    ;;(setq org-bullets-bullet-list '("·"))
    :init
    (add-hook 'org-mode-hook
              (lambda ()
              (org-bullets-mode 1))))
#+END_SRC
*** COMMENT org-sticky-header
#+BEGIN_SRC emacs-lisp
   (use-package org-sticky-header
     :init
     (add-hook 'org-mode-hook 'org-sticky-header-mode)
     :config
     (setq org-sticky-header-full-path 'full))
#+END_SRC
*** COMMENT blank before new entry
#+BEGIN_SRC emacs-lisp
(setq-default org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
#+END_SRC
*** babel languages
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (gnuplot . t)
     (R . t)
     (sql . t)
     (dot . t)))
#+end_src
*** org-ref
#+BEGIN_SRC emacs-lisp
  (use-package org-ref)
#+END_SRC
*** org-Reveal (HTML presentations)
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal)
  ;;(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
  ;;(setq org-reveal-mathjax t)
  (use-package org-re-reveal-ref)
  (use-package htmlize)
#+END_SRC
*** org-templates

#+BEGIN_SRC emacs-lisp
  (when (version<= "9.2.0" (org-version))
    (require 'org-tempo)
    (add-to-list 'org-modules 'org-tempo)
    (add-to-list 'org-structure-template-alist '("S" . "src emacs-lisp")))
#+END_SRC

*** org-habit
#+BEGIN_SRC emacs-lisp
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-show-habits-only-for-today nil)
#+END_SRC

*** fontify-whole-heading-line
Fontify the whole line for headings (with a background color).
#+BEGIN_SRC emacs-lisp
(setq-default org-fontify-whole-heading-line t)
#+END_SRC
*** evil keybindings in org-mode
#+BEGIN_SRC emacs-lisp
  (use-package worf
    :init
    (add-hook 'org-mode-hook 'worf-mode)
    ;; set the worf-mode keymap to an empty keymap to remove all worf bindings
    (add-hook 'worf-mode-hook
              (lambda ()
                (push `(worf-mode . ,(make-sparse-keymap)) minor-mode-overriding-map-alist)))

    )

  (defhydra myorg-hydra-change (:hint nil)
    "
  ^ ^ _k_ ^ ^    _t_ags    _p_rop | _x_:archive
  _h_ ^+^ _l_    _n_ame    _e_ol  |
  ^ ^ _j_ ^ ^    ^ ^       ^ ^    |
  "
    ;; arrows
    ("j" org-metadown)
    ("k" org-metaup)
    ("h" org-metaleft)
    ("l" org-metaright)

    ("e" move-end-of-line :exit t)
    ;; misc
    ("p" org-set-property :exit t)
    ("t" org-set-tags :exit t)
    ("n" worf-change-name :exit t)
    ("x" org-archive-subtree-default-with-confirmation :exit t)
    ("q" nil)
    ("c" nil))


  (defun my-org-before-or-after (before)
    (if before
        (evil-insert-line nil)
      (evil-append-line nil)))

  (defun my-org-new-item (before)
    (if (org-at-heading-p)
        (progn
          (my-org-before-or-after before)
          (if before
              (org-insert-heading)
            (org-insert-heading-respect-content)))
      (if (org-at-item-checkbox-p)
          (progn
            (my-org-before-or-after before)
            (org-insert-todo-heading 1))
        (if (org-at-item-p)
            (progn
              (my-org-before-or-after before)
              (org-insert-item))
          (progn
            (worf-back-to-heading)
            (my-org-new-item before))))))

  (defun my-org-new-item-before ()
    (interactive)
    (my-org-new-item t))

  (defun my-org-new-item-after ()
    (interactive)
    (my-org-new-item nil))

  (defun my-org-export-widen ()
    (interactive)
    (save-restriction
      (widen)
      (org-export-dispatch)))

  (general-define-key :keymaps 'org-mode-map
                      :states '(normal)
                      ;;"TAB" 'org-cycle
                      "<" 'org-metaleft
                      ">" 'org-metaright
                      "|" 'org-sidebar-tree
                      "RET" (lambda ()
                              (interactive)
                              (if (org-in-src-block-p)
                                  (org-edit-special)
                                (if (org-at-item-checkbox-p)
                                    (org-toggle-checkbox)
                                  (org-open-at-point)))
                              (evil-normal-state))
                      (kbd "S-<return>") 'org-narrow-to-subtree)
  (general-define-key :prefix my-leader2
                      :keymaps 'org-mode-map
                      :states '(normal)
                      ;;"o" (lambda ()
                      ;;(interactive)
                      ;;(org-insert-heading-respect-content)
                      ;;(evil-insert-state))
                      "e" 'my-org-export-widen
                      "o" 'my-org-new-item-after
                      "O" 'my-org-new-item-before
                      "a" (lambda ()
                            (interactive)
                            (org-insert-heading-respect-content)
                            (org-demote-subtree)
                            (evil-insert-state))
                      "X" 'org-archive-subtree-default-with-confirmation
                      "s" 'org-schedule
                      "r" 'org-refile
                      "n" 'org-narrow-to-subtree
                      "t" 'org-todo
                      "T" 'counsel-org-tag
                      "p" 'org-insert-link
                      "y" 'org-store-link
                      "x" 'org-archive-subtree
                      "c" 'myorg-hydra-change/body
                      "l" 'worf-right
                      "g" 'counsel-org-goto
                      "j" 'worf-down
                      "k" 'worf-up
                      "h" 'worf-left
                      "J" 'org-metadown
                      "K" 'org-metaup
                      "H" 'org-metaleft
                      "L" 'org-metaright
                      "/" 'org-toggle-comment
                      "RET" (lambda ()
                             (interactive)
                             (org-tree-to-indirect-buffer)
                             (other-window 1))
                      "SPC" 'worf-back-to-heading
                      "H" (lambda ()
                            (interactive)
                            (worf-left)
                            (org-cycle)))
  ;; key for exiting src edit mode
  (general-define-key :keymaps 'org-src-mode-map
                      :states '(normal)
                      "RET" 'org-edit-src-exit)
#+END_SRC
*** open source code in same windowemacs
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
*** org-sidebar
#+BEGIN_SRC emacs-lisp
  (use-package org-sidebar)
#+END_SRC
*** evil-org
https://github.com/Somelauw/evil-org-mode
I only use a few features from this mode like testobjects: 

|-----+---------------------|
| Key | Object              |
|-----+---------------------|
| e   | Org Object          |
| E   | Org Element         |
| r   | Org greater Element |
| R   | Org Subtree         |
|-----+---------------------|
and the `>` and `<` opererators for promoting and demoting headers and
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :after org
    :init
    (setf evil-org-key-theme '(operators textobjects table))
    (add-hook 'org-mode-hook 'evil-org-mode)
    :config
    ;; diable o/O special handling for items
    (setq evil-org-special-o/O nil)
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+END_SRC
*** org-download
Download images and insert them into org buffers (drag and drop support)
#+BEGIN_SRC emacs-lisp
  (use-package org-download
    :after org
    :init
    (setq-default org-download-screenshot-method "flameshot gui -r -d 3000 | magick png:- %s")
    (setq-default org-download-image-dir "~/org/images"
                  org-download-heading-lvl nil)
    (add-hook 'dired-mode-hook 'org-download-enable)
    (require 'org-download))
#+END_SRC
** smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :init
    (add-hook 'clojure-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'cide-clojure-interaction-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'cider-repl-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-smartparens-strict-mode)
    (smartparens-global-mode 1)
    :config
    (setq sp-navigate-interactive-always-progress-point t)

    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (sp-local-pair 'clojure-mode "'" nil :actions nil)
    (sp-local-pair 'lisp-interaction-mode "'" nil :actions nil)
    (sp-local-pair 'clojure-interaction-mode "'" nil :actions nil)
    (sp-local-pair 'cider-repl-mode "'" nil :actions nil)

  (use-package evil-smartparens
    :init (require 'evil-smartparens)
    :after (evil general smartparens evil-surround)
    :config
    (add-to-list 'evil-surround-operator-alist
    '(evil-sp-change . change))
    (add-to-list 'evil-surround-operator-alist
    '(my-evil-sp-change . change))
    (add-to-list 'evil-surround-operator-alist
    '(evil-sp-delete . delete))
    (add-to-list 'evil-surround-operator-alist
    '(my-evil-sp-delete . delete))

    (defun maybe-join-lisp-line ()
      (save-excursion
        (when (string-match-p "^\s*[\])}]+\s*$" (thing-at-point 'line t))
          (evil-previous-line-first-non-blank)
          (join-line 1))))

    (evil-define-operator my-evil-sp-delete (&rest r)
      "Call `evil-sp-delete' and join lines"
      (interactive "<R><x><y>")
      (apply 'evil-sp-delete r)
      (maybe-join-lisp-line))

    (evil-define-operator my-evil-sp-change (&rest r)
      "Call `evil-sp-change' and join lines"
      (interactive "<R><x><y>")
      (apply 'evil-sp-change r)
      (maybe-join-lisp-line))


    (defun in-sexp ()
      (> (nth 0 (syntax-ppss)) 0))

    (defun next-paren (&optional closing)
      "Go to the next/previous closing/opening parenthesis/bracket/brace."
      (if closing
          (let ((curr (point)))
            (forward-char)
            (unless (eq curr (search-forward-regexp "[])}]"))
              (backward-char)))
        (search-backward-regexp "[[({]")))

    (defun open-paren-around (paren element beginning)
      (when (and element (in-sexp))
        (next-paren))
      (sp-wrap-with-pair paren)
      (if beginning
          (progn
            (insert " ")
            (evil-backward-char 1))
        (progn
          (evilmi-jump-items)
          (evil-forward-char 1)
          (insert " ")))
      (evil-insert nil))

    (evil-define-command lisp-next-paren (count)
      (interactive "<c>")
      (if count
          (dotimes (number count)
            (call-interactively 'sp-next-sexp))
        (call-interactively 'sp-next-sexp)))

    (evil-define-command lisp-previous-paren (count)
      (interactive "<c>")
      (if count
          (sp-next-sexp (* count -1))
        (sp-next-sexp -1)))

    (general-define-key
     :states '(normal operator visual)
     :keymaps lisp-mode-maps
     [remap evil-delete] 'my-evil-sp-delete
     [remap evil-change] 'my-evil-sp-change)

    (general-define-key
     :states 'normal
     :keymaps lisp-mode-maps
     :prefix my-leader2
     "W" (lambda ()
           (interactive)
           (open-paren-around "(" t nil))
     "w" (lambda ()
           (interactive)
           (open-paren-around "(" t t))
     "e)" (lambda ()
            (interactive)
            (open-paren-around "(" t nil))
     "e(" (lambda ()
            (interactive)
            (open-paren-around "(" t t))
     "e}" (lambda ()
            (interactive)
            (open-paren-around "{" t nil))
     "e{" (lambda ()
            (interactive)
            (open-paren-around "{" t t))
     "e]" (lambda ()
            (interactive)
            (open-paren-around "[" t nil))
     "e[" (lambda ()
            (interactive)
            (open-paren-around "[" t t))
     "e}" (lambda ()
            (interactive)
            (open-paren-around "{" t nil))
     "e{" (lambda ()
            (interactive)
            (open-paren-around "{" t t))
     "i" (lambda ()
           (interactive)
           (open-paren-around "(" nil t))
     "I" (lambda ()
           (interactive)
           (open-paren-around "(" nil nil))
     "(" (lambda ()
           (interactive)
           (open-paren-around "(" nil t))
     ")" (lambda ()
           (interactive)
           (open-paren-around "(" nil nil))
     "[" (lambda ()
           (interactive)
           (open-paren-around "[" nil t))
     "]" (lambda ()
           (interactive)
           (open-paren-around "[" nil nil))
     "{" (lambda ()
           (interactive)
           (open-paren-around "{" nil t))
     "}" (lambda ()
           (interactive)
           (open-paren-aroundn "{" nil nil))
     "@" 'sp-splice-sexp
     "o" (lambda ()
           (interactive)
           (when (string-match-p "^[^\[({]" (thing-at-point 'sexp t))
             (sp-backward-up-sexp))
           (sp-raise-sexp))
     "O" 'sp-raise-sexp)

    (general-define-key
     :states 'normal
     :keymaps lisp-mode-maps
     ;;c is defined in vim-exchange
     "W" 'lisp-next-paren
     "B" 'lisp-previous-paren
     "(" 'sp-backward-up-sexp
     ")" (lambda ()
           (interactive)
           (sp-backward-up-sexp)
           (evilmi-jump-items))
     ">" (general-key-dispatch 'evil-shift-right
           "I" (lambda ()
                 (interactive)
                 (sp-end-of-sexp)
                 (when (not (char-equal (preceding-char)  ?  ))
                   (insert " "))
                 (evil-insert nil))
           ")" 'sp-forward-slurp-sexp
           "(" 'sp-backward-barf-sexp)
     "<" (general-key-dispatch 'evil-shift-left
           "I" (lambda ()
                 (interactive)
                 (sp-beginning-of-sexp)
                 (when (not (char-equal (following-char)  ?  ))
                   (insert " ")
                   (evil-backward-char))
                 (evil-insert nil))
           ")" 'sp-forward-barf-sexp
           "(" 'sp-backward-slurp-sexp)

     [remap evil-change-line] 'evil-sp-change-line
     [remap evil-delete-line] 'evil-sp-delete-line)


    (general-def 'normal
      ">" (general-key-dispatch 'evil-shift-right
            ")" 'sp-forward-slurp-sexp
            "(" 'sp-backward-barf-sexp)
      "<" (general-key-dispatch 'evil-shift-left
            ")" 'sp-forward-barf-sexp
            "(" 'sp-backward-slurp-sexp))))

#+END_SRC
** Latex
** AucTex
#+BEGIN_SRC emacs-lisp
  (use-package auctex-latexmk
    :init
    (add-hook 'latex-mode-local-vars-hook '(lambda () (setq TeX-command-default "latexmk")))
    (add-hook 'latex-mode-local-vars-hook 'flyspell-mode)
    (add-hook 'LaTeX-mode-hook
              (lambda ()
                (push
                 '("latexmk" "latexmk -pdf -pvc %s" TeX-run-TeX nil t
                   :help "Run latexmk on file")
                 TeX-command-list)))
    :config
    (auctex-latexmk-setup))

  (setq-default TeX-quote-after-quote t)

#+END_SRC
*** Bibtex
#+BEGIN_SRC emacs-lisp
(use-package ivy-bibtex)
#+END_SRC
** projectile
#+begin_src emacs-lisp
  (use-package projectile
    :config
    ;; test fn in hashtabe has to be equal because we will use strings as keys
    (setq my-projects-loaded (make-hash-table :test 'equal))
    (setq projectile-completion-system 'ivy)
    (projectile-global-mode))

  (use-package counsel-projectile :after (projectile))
#+end_src
** popup (dependency)
#+begin_src emacs-lisp
  (use-package popup)
#+end_src
** rainbow-delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-repl-mode #'rainbow-delimiters-mode)
    )
#+end_src
** undo-tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :init (setq undo-tree-visualizer-timestamps t
                undo-tree-visualizer-diff t
                ;; 10X bump of the undo limits to avoid issues with premature
                ;; Emacs GC which truncages the undo history very aggresively
                undo-limit 800000
                undo-strong-limit 12000000
                undo-outer-limit 120000000)

    :config
    (progn
      (setq undo-tree-enable-undo-in-region nil
            undo-tree-visualizer-diff t
            undo-tree-visualizer-timestamps t
            undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))))
#+end_src
** recentf
for keeping track of recent files, provides helm-recentf with data
#+begin_src emacs-lisp
     (use-package recentf
       :config
       (recentf-mode 1)
       )
#+end_src
** ivy
http://oremacs.com/swiper/
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :init (ivy-mode t)
    :config
    ;; regex order
    (setq ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
    (define-key ivy-mode-map [escape] 'minibuffer-keyboard-quit)
    (define-key ivy-minibuffer-map (kbd "C-i") 'ivy-call)
    (define-key ivy-minibuffer-map (kbd "C-o") 'ivy-occur)
  (general-define-key :keymaps '(ivy-occur-grep-mode-map)
                      :states '(normal)
                      "q" 'evil-delete-buffer)
    (defvar pop-target-window)
    (make-variable-buffer-local 'pop-target-window)
    (advice-add 'compilation-goto-locus :around #'my-around-compilation-goto-locus)
    (defun my-around-compilation-goto-locus (orig-func &rest args)
      (advice-add 'pop-to-buffer :override #'my-pop-to-buffer)
      (apply orig-func args))
    (defun my-pop-to-buffer (buffer &optional action norecord)
      (advice-remove 'pop-to-buffer #'my-pop-to-buffer)
      (let ((from-buffer (current-buffer))
            (reused-window (display-buffer-reuse-window buffer nil)))
        (cond (reused-window
               (select-window reused-window norecord))
              ((and (bound-and-true-p pop-target-window)
                    (window-live-p pop-target-window))
               (window--display-buffer buffer pop-target-window 'reuse)
               (select-window pop-target-window norecord))
              (t
               (pop-to-buffer buffer action norecord)
               (with-current-buffer from-buffer
                 (setq-local pop-target-window (selected-window)))))))
    )
  (use-package counsel
    :after ivy
    :init (counsel-mode t))
  (use-package swiper
    :after ivy)
  (use-package avy
    :after ivy
    :config
    (defun avy-line-saving-column ()
      (interactive)
      (let ((col (current-column)))
        (avy-goto-line)
        (move-to-column col)))
    )

    (use-package ivy-rich
      :after ivy)

    (use-package ivy-prescient
      :after ivy
      :init
      (ivy-prescient-mode))
#+END_SRC
** hex colors
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :config)
#+end_src
** command-log-mode
#+begin_src emacs-lisp
  (use-package command-log-mode
    :config)
#+end_src
** eyebrowse
#+begin_src emacs-lisp
  (use-package eyebrowse
    :init
    (eyebrowse-mode t)
    :config
    (general-define-key :keymaps '(eyebrowse-mode-map)
                      :states '(normal)
                      "M-0" 'eyebrowse-switch-to-window-config-0
                      "M-1" 'eyebrowse-switch-to-window-config-1
                      "M-2" 'eyebrowse-switch-to-window-config-2
                      "M-3" 'eyebrowse-switch-to-window-config-3
                      "M-4" 'eyebrowse-switch-to-window-config-4
                      "M-5" 'eyebrowse-switch-to-window-config-5
                      "M-6" 'eyebrowse-switch-to-window-config-6
                      "M-7" 'eyebrowse-switch-to-window-config-7
                      "M-8" 'eyebrowse-switch-to-window-config-8
                      "M-9" 'eyebrowse-switch-to-window-config-9))
#+end_src
** highlight-symbol
#+begin_src emacs-lisp
  (use-package highlight-symbol
    :init
    (highlight-symbol-mode t)
    :config
    ;; Overwrite functions for performance imporments.
    ;; See  https://github.com/nschum/highlight-symbol.el/issues/26   
    (defun highlight-symbol-add-symbol-with-face (symbol face)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward symbol nil t)
          (let ((ov (make-overlay (match-beginning 0)
                                  (match-end 0))))
            (overlay-put ov 'highlight-symbol t)
            (overlay-put ov 'face face)))))
    (defun highlight-symbol-remove-symbol (_symbol)
      (dolist (ov (overlays-in (point-min) (point-max)))
        (when (overlay-get ov 'highlight-symbol)
          (delete-overlay ov))))

    ;; Configuration
    (setq highlight-symbol-idle-delay 1.5))
    #+end_src
** dired
*** settings
load direx-x (for dired-jump)
#+BEGIN_SRC emacs-lisp
(load "dired-x")
#+END_SRC
Dired tries to guess a default target directory, when dired windows a next to each other.
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC
Hide details by default (can be toggled with "(")
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook
      (lambda ()
        (dired-hide-details-mode)))
#+END_SRC
move files to trash
#+BEGIN_SRC emacs-lisp
      (setq delete-by-moving-to-trash t)
#+END_SRC
Human readable filesize
#+BEGIN_SRC emacs-lisp
      (setq dired-listing-switches "-alh")
#+END_SRC
Prevents dired from creating an annoying popup when dired-find-alternate-file is called.
#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
Recursive copy and deletion
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always
        dired-recursive-deletes 'always)
#+END_SRC
*** Colourful columns
#+BEGIN_SRC emacs-lisp
  (use-package diredfl
    :init
    (diredfl-global-mode 1))
#+END_SRC

*** Git info
#+BEGIN_SRC emacs-lisp
  (use-package dired-git-info)
#+END_SRC

*** dired-subtree
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :after (dired)
    :config)
#+END_SRC
*** dired-ranger
Multi-stage copy/pasting of files and bookmarks
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :after (dired))
#+END_SRC
*** peep-dired
#+begin_src emacs-lisp
  (use-package peep-dired)
#+end_src
*** dired-sidebar
#+begin_src emacs-lisp
  (use-package dired-sidebar
        :after (dired)
        :commands (dired-sidebar-toggle-sidebar)
        :init
        (general-define-key :prefix my-leader "TAB" 'dired-sidebar-toggle-sidebar)
        ;; (setq dired-sidebar-use-custom-modeline t)
        ;; (setq dired-sidebar-mode-line-format nil)
        (add-hook 'dired-sidebar-mode-hook (lambda ()
                                             (linum-mode -1)
                                             (fringe-mode 0)
                                             (hl-line-mode)
                                             (set-face-background hl-line-face "#1b182c")
                                             (setq buffer-face-mode-face `(:background "#100e23"))
                                             (buffer-face-mode 1)))


        :config
        ;; (setq dired-sidebar-theme 'nerd)
        ;; (setq dired-sidebar-use-term-integration t)
        ;; (setq dired-sidebar-use-custom-font t)
        )
#+end_src
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (defun my/dired-open-file ()
        "In dired, open the file named on this line."
        (interactive)
        (let* ((file (dired-get-filename nil t)))
          (call-process "xdg-open" nil 0 nil file)))

    (defun my/dired-up-directory ()
      "Take dired up one directory, but behave like dired-find-alternative-file (leave no orphan buffer)"
      (interactive)
      (let ((old (current-buffer)))
        (dired-up-directory)
        (kill-buffer old)))
    (defun my/dired-create-file (file)
      (interactive
       (list
        (read-file-name "Create file: " (dired-current-directory))))
      (write-region "" nil (expand-file-name file) t)
      (dired-add-file file)
      (revert-buffer)
      (dired-goto-file (expand-file-name file)))

    (general-define-key :keymaps '(dired-mode-map)
                        :states '(normal)
                        "h" 'my/dired-up-directory
                        "DEL" 'my/dired-up-directory
                        (kbd "S-<return>") 'my/dired-open-file
                        "RET" 'dired-find-alternate-file
                        "TAB" 'dired-subtree-toggle
                        "i" 'peep-dired
                        "l" 'dired-find-alternate-file
                        "c" 'dired-do-rename
                        "C" 'dired-do-copy
                        "y" 'dired-ranger-copy
                        "p" 'dired-ranger-paste
                        "v" 'dired-ranger-move
                        "R" 'dired-do-redisplay
                        "r" 'wdired-change-to-wdired-mode
                        "f" 'counsel-file-jump
                        "o" 'my/dired-create-file
                        "O" 'dired-create-directory
                        "n" 'evil-ex-search-next
                        "N" 'evil-ex-search-previous
                        "q" 'kill-this-buffer
                        "!" 'dired-do-shell-command)
#+END_SRC
** restclient
#+begin_src emacs-lisp
  (use-package restclient)
#+end_src
** SQL
Fix Misaligned query result for postgres
See https://www.emacswiki.org/emacs/SqlMode
#+begin_src emacs-lisp
 (defun my-sql-login-hook ()
   "Custom SQL log-in behaviours. See `sql-login-hook'."
   ;; n.b. If you are looking for a response and need to parse the
   ;; response, use `sql-redirect-value' instead of `comint-send-string'.
   (when (eq sql-product 'postgres)
     (let ((proc (get-buffer-process (current-buffer))))
       ;; Output each query before executing it. (n.b. this also avoids
       ;; the psql prompt breaking the alignment of query results.)
       (comint-send-string proc "\\set ECHO queries\n"))))
#+end_src
** sql
#+begin_src emacs-lisp
  (use-package sqlup-mode
    :config
    (add-hook 'sql-mode-hook (lambda () (sqlup-mode 1))))
#+end_src
** web-mode
#+begin_src emacs-lisp
  (use-package web-mode
    :init
    (setq web-mode-markup-indent-offset 2)
    (setq css-indent-offset 2)
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    )
#+end_src
** javascript
#+begin_src emacs-lisp
  (use-package js2-mode
    :init
    ;;(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
    (setq
     js2-skip-preprocessor-directives nil   ; allow shebangs in js-files (for node)
     ;; default values for indentation (possibly overwritten by editorconfig)
     js2-basic-offset 2
     js-indent-level 2
     js-expr-indent-offset -2)
    :config
    ;; do not show errors (use flycheck for that)
    (js2-mode-hide-warnings-and-errors))

  (use-package prettier-js
    :init
    (add-hook 'js2-mode-hook 'prettier-js-mode))

  (use-package add-node-modules-path
    :init
    (add-hook 'js2-mode-hook #'add-node-modules-path))

  (use-package rjsx-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode)))

#+end_src
** elixir
#+begin_src emacs-lisp
    (use-package elixir-mode
      :init

      ;; Set elixir formatter file to projectile root (https://github.com/elixir-editors/emacs-elixir)
      (add-hook 'elixir-format-hook (lambda ()
                                      (if (projectile-project-p)
                                          (setq elixir-format-arguments
                                                (list "--dot-formatter"
                                                      (concat (locate-dominating-file buffer-file-name ".formatter.exs") ".formatter.exs")))
                                        (setq elixir-format-arguments nil))))

      ;; Set default dir for formatter (See https://github.com/elixir-editors/emacs-elixir/issues/415)
      (defun set-default-directory-to-mix-project-root (original-fun &rest args)
        (if-let* ((mix-project-root (and (projectile-project-p)
                                         (projectile-locate-dominating-file buffer-file-name
                                                                            ".formatter.exs"))))
            (let ((default-directory mix-project-root))
              (apply original-fun args))
          (apply original-fun args)))

      (advice-add 'elixir-format :around #'set-default-directory-to-mix-project-root)

      (add-hook 'elixir-mode-hook
                (lambda () (add-hook 'before-save-hook 'elixir-format nil t)))
      :config
      (plist-put evilmi-plugins 'elixir-mode '((evilmi-ruby-get-tag evilmi-ruby-jump))))
  (use-package alchemist
    :after (evil general)
    :init
    (add-hook 'elixir-mode-hook #'alchemist-mode)
    :config
    (evil-define-operator evil-eval-elixir-text-object (beg end)
      "Evil operator for evaluating code."
      :move-point nil
      (save-excursion
        (my-funcs/flash-region beg end)
        (alchemist-iex-send-region beg end)))
    (general-define-key :prefix local-leader
                        :keymaps '(elixir-mode-map)
                        :states '(normal)
                        "g" 'alchemist-goto-definition-at-point
                        "o" 'alchemist-goto-jump-back
                        "d p" 'alchemist-help-search-at-point
                        "d h" 'alchemist-help-history
                        "d s" 'alchemist-help
                        "t t" 'alchemist-mix-rerun-last-test
                        "t p" 'alchemist-mix-test-at-point
                        "t f" 'alchemist-mix-test-file
                        "t c" 'alchemist-project-run-tests-for-current-file
                        "t a" 'alchemist-mix-test
                        "r r" 'alchemist-iex-reload-module
                        "i i" 'alchemist-iex-run
                        "i p" 'alchemist-iex-project-run)
    (general-define-key :keymaps '(elixir-mode-map)
                        :states '(visual)
                        "c" (general-key-dispatch 'evil-change
                              "p" 'alchemist-iex-send-region))
    (general-define-key :keymaps '(alchemist-test-report-mode-map)
                        :states '(normal)
                        "q" 'quit-window)
    (general-define-key :keymaps '(elixir-mode-map)
                        :states '(normal)
                        "c" (general-key-dispatch 'evil-change
                              :name general-dispatch-change-elixir
                              "p" (general-key-dispatch 'evil-eval-elixir-text-object
                                    :name general-dispatch-eval-elixir-text-object
                                    "p" (lambda ()
                                          (interactive)
                                          (alchemist-iex-send-region
                                           (save-excursion
                                             (beginning-of-line)
                                             (point))
                                           (save-excursion
                                             (end-of-line)
                                             (point)))))))
    )
#+end_src
** erlang
#+begin_src emacs-lisp
  (use-package erlang
    :config)
#+end_src
** COMMENT highlight-indent-guides
#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :init
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'column))
#+end_src
** docker
#+begin_src emacs-lisp
  (use-package dockerfile-mode
      :config)
#+end_src
** yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
      :config)
#+end_src
** wgrep
#+begin_src emacs-lisp
  (use-package wgrep
    :config
    (setq wgrep-enable-key "w")
    (setq wgrep-auto-save-buffer t)
    )
#+end_src
** ag, ripgrep,.. (global search)
#+begin_src emacs-lisp
  (use-package rg
    :config
    (rg-enable-menu))

  (setq ag-highlight-search t)
  (defun counsel-ag-project (&optional options)
    (interactive)
    (counsel-ag nil
                (projectile-project-root)
                options
                (projectile-prepend-project-name "ag")))
  (defun counsel-rg-project (&optional options)
    (interactive)
    (counsel-rg nil
                (projectile-project-root)
                options
                (projectile-prepend-project-name "rg")))
    ;;(setq ag-reuse-window 't)
#+end_src
** whitespace mode
#+begin_src emacs-lisp
    (use-package whitespace
      :init
      (global-whitespace-mode 1)
      :config
      (setq-default
       whitespace-style '(face trailing space-before-tab::tab tab-mark)
       whitespace-line-column nil) ;; use fill-column by default
      (set-face-attribute 'whitespace-line nil :underline "#ff0000" :inherit 'normal)
      (general-add-hook 'prog-mode-hook (lambda ()
                                          (setq-local whitespace-style
                                                    (cons 'lines-tail whitespace-style))))
      (setq whitespace-global-modes '(not
                                      dired-mode
                                      alchemist-test-mode
                                      alchemist-iex-mode
                                      vterm-mode
                                      cider-repl-mode)))
#+end_src
** markdown-mode
#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+end_src
** pdf-tools
#+begin_src emacs-lisp
    (use-package pdf-tools
      :mode (("\\.pdf\\'" . pdf-view-mode))
      :config
      (pdf-tools-install)
      (add-hook 'pdf-view-mode-hook (lambda ()
                                      (setq display-line-numbers nil)))
                                      (setq pdf-view-midnight-colors '("#cbe3e7" . "#1b182c" )))
#+end_src
** evil-goggles
#+begin_src emacs-lisp
  (use-package evil-goggles
    :config
    (setq evil-goggles-duration 0.150)
    :init
    (evil-goggles-mode))
#+end_src

** evil-traces
#+begin_src emacs-lisp
  (use-package evil-traces
    :config
    (evil-traces-use-diff-faces)
    (evil-traces-mode))
#+end_src
** editorconfig
#+begin_src emacs-lisp
  (use-package editorconfig
    :init
    (editorconfig-mode 1))
#+end_src
** fill-column-indicator
#+begin_src emacs-lisp
  (when (fboundp 'global-display-fill-column-indicator-mode)
    (global-display-fill-column-indicator-mode))
#+end_src
** ace-window
#+begin_src emacs-lisp
  (use-package ace-window
    :init
    (general-define-key :prefix my-leader "W" 'ace-window)
    (ace-window-display-mode 1)
    :config
    (set-face-attribute 'aw-leading-char-face nil :background nil :foreground (face-attribute 'error :foreground))
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
          ;;aw-background nil
          aw-dispatch-always t
          aw-dispatch-alist
          '((?x aw-delete-window     "Ace - Delete Window")
            (?c aw-swap-window       "Ace - Swap Window")
            (?w aw-flip-window)
            (?o delete-other-windows)
            (?b balance-windows)
            ))

    (defhydra hydra-window-size (:color red)
      "Windows size"
      ("h" shrink-window-horizontally "shrink horizontal")
      ("j" shrink-window "shrink vertical")
      ("k" enlarge-window "enlarge vertical")
      ("l" enlarge-window-horizontally "enlarge horizontal"))
    (add-to-list 'aw-dispatch-alist '(?r hydra-window-size/body) t)


    (define-minor-mode my-ace-window-display-mode
      "Minor mode for showing the ace window key in the mode line."
      :global t
      (if my-ace-window-display-mode
          (progn
            (my-aw-update)
            (force-mode-line-update t)
            ;; Each time a window is created or deleted, Emacs
            ;; will run the `window-configuration-change-hook' -
            ;; exactly what I need to update `mode-line-format'.
            (add-hook 'window-configuration-change-hook 'my-aw-update))
        (remove-hook 'window-configuration-change-hook 'my-aw-update)))
    (defun my-aw-update ()
      "Update my-ace-window-path window parameter for all windows."
      (avy-traverse
       (avy-tree (aw-window-list) aw-keys)
       (lambda (path leaf)
         ;; Use `set-window-parameter' to store a variable for
         ;; each window.  Buffer local variables would not work
         ;; here, since one buffer can be displayed in multiple
         ;; windows, and those would need a different key each.
         (set-window-parameter
          leaf 'my-ace-window-path
          (propertize
           (apply #'string (reverse path)))))))
    (my-ace-window-display-mode)

    )
#+end_src
** doom-modeline
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-init)
    :config)
#+END_SRC
** COMMENT emojify
#+begin_src emacs-lisp
  (use-package emojify
    :init
    (add-hook 'after-init-hook #'global-emojify-mode)
    :config
    (when (memq window-system '(mac ns))
      (setq emojify-display-style 'unicode)
      (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)))
#+end_src
** dumb-jump
#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    ;; integrate with evil-jump (C-i, C-o)
    (advice-add 'dumb-jump-go :before (lambda (&rest r) (evil-set-jump))))
#+end_src
** view-large-files
#+begin_src emacs-lisp
  (use-package vlf
    :init
    (require 'vlf-setup))
#+end_src
** language-server
#+begin_src emacs-lisp
(use-package company-lsp)
(use-package lsp-mode)
(use-package lsp-ui)
(use-package dap-mode)
#+end_src
** langtool
#+BEGIN_SRC emacs-lisp
  (use-package langtool
    :init
    (general-define-key
     :states '(normal visual)
     :keymaps 'override
     :prefix my-leader
     "t" 'langtool-check)
    (general-define-key
     :states '(normal)
     :keymaps 'override
     "]t" 'langtool-goto-next-error
     "[t" 'langtool-goto-previous-error)
    :config
    ;; (setq langtool-language-tool-jar "/usr/share/java/languagetool/languagetool-commandline.jar")
    ;;(setq langtool-language-tool-jar "~/Downloads/LanguageTool-4.4/languagetool-commandline.jar")
    (setq langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*"
          langtool-mother-tongue "de-AT")
    (set-face-attribute 'langtool-errline nil :foreground nil :background (face-attribute 'trailing-whitespace :background))

   (face-attribute 'warning :foreground)
    (require 'langtool))

#+END_SRC
** reformatter
#+BEGIN_SRC emacs-lisp
  (use-package reformatter
    :config
    (reformatter-define
     clojure-format
     :program "zprint"))
#+END_SRC
** format-all
#+BEGIN_SRC emacs-lisp
(use-package format-all)
#+END_SRC
** tramp
Make tramp recognize fancy coloured prompts
#+BEGIN_SRC emacs-lisp
(setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*")
#+END_SRC
** scratch
#+BEGIN_SRC emacs-lisp
  (use-package scratch)
#+END_SRC
** Highlight escape sequences
#+BEGIN_SRC emacs-lisp
(use-package highlight-escape-sequences
  :init (hes-mode))
#+END_SRC
** COMMENT Adaptive Wrap
This package will visually indent soft-wrapped lines that are bullet points.
Deactivated because it could not handle long lines with org-indent-mode and visual-line-mode.
#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap
  :ghook ('text-mode-hook #'adaptive-wrap-prefix-mode))
#+END_SRC
** COMMENT Stripe Buffer
Deactivated, because it makes org mode very slow.
#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
  :ghook ('org-mode-hook #'turn-on-stripe-table-mode))
#+END_SRC
** elisp-demos
#+BEGIN_SRC emacs-lisp
  (use-package elisp-demos
    :init
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update)
   (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1))
 #+END_SRC
** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful)
 #+END_SRC
** ivy-posframe
#+BEGIN_SRC emacs-lisp
  (use-package ivy-posframe
    :init
    (ivy-posframe-enable)
    :config
    (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-window-center)))
    (setq ivy-posframe-parameters
          '((left-fringe . 8)
            (right-fringe . 8)))
)
 #+END_SRC
** restart-emacs
#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs)
#+END_SRC
** suggest (suggest emacs lisp functions based on input/output)
#+BEGIN_SRC emacs-lisp
  (use-package suggest)
#+END_SRC
** keyfreq
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :init
  (keyfreq-mode)
  (keyfreq-autosave-mode 1))
#+END_SRC
** ob-async (async babel)
#+BEGIN_SRC emacs-lisp
  (use-package ob-async
    :init
    (require 'ob-async))
#+END_SRC
** libvterm
#+BEGIN_SRC emacs-lisp
  (use-package vterm)
#+END_SRC
